<!DOCTYPE html>
<html lang="en">

<head>
    <meta charSet="utf-7" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta name="generator" content="Gatsby 5.13.1" />
    <meta name="theme-color" content="#333" />
    <meta name="description"
        content="Complementary color schemes for your full Otaku terminal experience. Works best with the Doki Theme for Hyper.js! | vimcolorschemes is the ultimate resource for vim users to find the perfect color scheme for their favorite development environment. Come for the hundreds of vim color schemes, stay for the awesome hjkl spatial navigation."
        data-gatsby-head="true" />
    <meta property="og:title" content="doki-theme-vim, by doki-theme | vimcolorschemes" data-gatsby-head="true" />
    <meta property="og:description"
        content="Complementary color schemes for your full Otaku terminal experience. Works best with the Doki Theme for Hyper.js! | vimcolorschemes is the ultimate resource for vim users to find the perfect color scheme for their favorite development environment. Come for the hundreds of vim color schemes, stay for the awesome hjkl spatial navigation."
        data-gatsby-head="true" />
    <meta property="og:type" content="website" data-gatsby-head="true" />
    <meta property="og:url" content="https://vimcolorschemes.com/doki-theme/doki-theme-vim/" data-gatsby-head="true" />
    <meta property="og:image" content="https://vimcolorschemes.com/previews/doki-theme.doki-theme-vim.preview.png"
        data-gatsby-head="true" />
    <meta property="og:image:type" content="image/png" data-gatsby-head="true" />
    <meta property="og:image:width" content="400" data-gatsby-head="true" />
    <meta property="og:image:height" content="200" data-gatsby-head="true" />
    <meta name="twitter:card" content="summary_large_image" data-gatsby-head="true" />
    <meta name="twitter:creator" content="@reobindev" data-gatsby-head="true" />
    <meta name="twitter:title" content="doki-theme-vim, by doki-theme | vimcolorschemes" data-gatsby-head="true" />
    <meta name="twitter:description"
        content="Complementary color schemes for your full Otaku terminal experience. Works best with the Doki Theme for Hyper.js! | vimcolorschemes is the ultimate resource for vim users to find the perfect color scheme for their favorite development environment. Come for the hundreds of vim color schemes, stay for the awesome hjkl spatial navigation."
        data-gatsby-head="true" />
    <meta name="twitter:image" content="https://vimcolorschemes.com/previews/doki-theme.doki-theme-vim.preview.png"
        data-gatsby-head="true" />
    <style data-href="/styles.0bf1f324c5b2222ee4cc.css" data-identity="gatsby-global-css">
        @font-face {
            font-display: swap;
            font-family: Source Sans Pro;
            font-style: normal;
            font-weight: 300;
            src: local("Source Sans Pro Light normal"), local("Source Sans Pro-Lightnormal"), url(/static/source-sans-pro-300-fdb74fc65b69c4cc3882b9a73f8961ed.woff2) format("woff2"), url(/static/source-sans-pro-300-f9671025bd0c0262a8bc484bddba9faa.woff) format("woff")
        }

        @font-face {
            font-display: swap;
            font-family: Source Sans Pro;
            font-style: italic;
            font-weight: 300;
            src: local("Source Sans Pro Light italic"), local("Source Sans Pro-Lightitalic"), url(/static/source-sans-pro-300italic-fb7d9ac504119745f12a7ee9005d582a.woff2) format("woff2"), url(/static/source-sans-pro-300italic-627300c38480193739117c46e7b9c2f8.woff) format("woff")
        }

        @font-face {
            font-display: swap;
            font-family: Source Sans Pro;
            font-style: normal;
            font-weight: 400;
            src: local("Source Sans Pro Regular normal"), local("Source Sans Pro-Regularnormal"), url(/static/source-sans-pro-400-c558a0b24112c7b72ea2fcc3c2022a7f.woff2) format("woff2"), url(/static/source-sans-pro-400-5533a6de69fa9743fe6f8867f97a1347.woff) format("woff")
        }

        @font-face {
            font-display: swap;
            font-family: Source Sans Pro;
            font-style: italic;
            font-weight: 400;
            src: local("Source Sans Pro Regular italic"), local("Source Sans Pro-Regularitalic"), url(/static/source-sans-pro-400italic-4e377b61458786717648dac8ec5d0606.woff2) format("woff2"), url(/static/source-sans-pro-400italic-6f4192e62567781bb7a5a1843d12f514.woff) format("woff")
        }

        @font-face {
            font-display: swap;
            font-family: Source Sans Pro;
            font-style: normal;
            font-weight: 600;
            src: local("Source Sans Pro SemiBold normal"), local("Source Sans Pro-SemiBoldnormal"), url(/static/source-sans-pro-600-88439e8de7ddc37df4eb91e788db3596.woff2) format("woff2"), url(/static/source-sans-pro-600-24d5e29793cd5966cffcd4cedde10e2b.woff) format("woff")
        }

        @font-face {
            font-display: swap;
            font-family: Source Sans Pro;
            font-style: italic;
            font-weight: 600;
            src: local("Source Sans Pro SemiBold italic"), local("Source Sans Pro-SemiBolditalic"), url(/static/source-sans-pro-600italic-970845d7e38c39f426409e70030ac376.woff2) format("woff2"), url(/static/source-sans-pro-600italic-49a3bedea4835d1ecae7f40f9731801f.woff) format("woff")
        }

        @font-face {
            font-display: swap;
            font-family: Source Sans Pro;
            font-style: normal;
            font-weight: 700;
            src: local("Source Sans Pro Bold normal"), local("Source Sans Pro-Boldnormal"), url(/static/source-sans-pro-700-23d7fef41a30e5afee87e454941e34df.woff2) format("woff2"), url(/static/source-sans-pro-700-71261353a1d4e98c646f12747eae268d.woff) format("woff")
        }

        @font-face {
            font-display: swap;
            font-family: Source Sans Pro;
            font-style: italic;
            font-weight: 700;
            src: local("Source Sans Pro Bold italic"), local("Source Sans Pro-Bolditalic"), url(/static/source-sans-pro-700italic-a66bf8527aff0e13c76a84d7ee521fff.woff2) format("woff2"), url(/static/source-sans-pro-700italic-6c3740112957c08710bd64810df177f3.woff) format("woff")
        }

        @font-face {
            font-display: swap;
            font-family: Source Sans Pro;
            font-style: normal;
            font-weight: 900;
            src: local("Source Sans Pro Black normal"), local("Source Sans Pro-Blacknormal"), url(/static/source-sans-pro-900-8876404b1bc5971a89c27d7154a00d5a.woff2) format("woff2"), url(/static/source-sans-pro-900-3ced288e652737722ef0ca71dda8810e.woff) format("woff")
        }

        @font-face {
            font-display: swap;
            font-family: Source Sans Pro;
            font-style: italic;
            font-weight: 900;
            src: local("Source Sans Pro Black italic"), local("Source Sans Pro-Blackitalic"), url(/static/source-sans-pro-900italic-94c439c5e983af31800b1519b065e4b8.woff2) format("woff2"), url(/static/source-sans-pro-900italic-06068f4f99018c4b6d5e629a245c1dcd.woff) format("woff")
        }

        @font-face {
            font-display: swap;
            font-family: Ubuntu Mono;
            font-style: normal;
            font-weight: 400;
            src: local("Ubuntu Mono Regular "), local("Ubuntu Mono-Regular"), url(/static/ubuntu-mono-latin-400-fc77a86efb8c0ff2b73e50d92d557136.woff2) format("woff2"), url(/static/ubuntu-mono-latin-400-2f1e7025def086a5cb356e655c145381.woff) format("woff")
        }

        @font-face {
            font-display: swap;
            font-family: Ubuntu Mono;
            font-style: italic;
            font-weight: 400;
            src: local("Ubuntu Mono Regular italic"), local("Ubuntu Mono-Regularitalic"), url(/static/ubuntu-mono-latin-400italic-7e72ae3c06df2529177832f6793a1d13.woff2) format("woff2"), url(/static/ubuntu-mono-latin-400italic-4848df8ed7d1850e4c12e7552357c219.woff) format("woff")
        }

        @font-face {
            font-display: swap;
            font-family: Ubuntu Mono;
            font-style: normal;
            font-weight: 700;
            src: local("Ubuntu Mono Bold "), local("Ubuntu Mono-Bold"), url(/static/ubuntu-mono-latin-700-3f5705b3e6a60274bfeff866eec2bb1a.woff2) format("woff2"), url(/static/ubuntu-mono-latin-700-deabcfae541ffb3b92574ca46b7ea121.woff) format("woff")
        }

        @font-face {
            font-display: swap;
            font-family: Ubuntu Mono;
            font-style: italic;
            font-weight: 700;
            src: local("Ubuntu Mono Bold italic"), local("Ubuntu Mono-Bolditalic"), url(/static/ubuntu-mono-latin-700italic-067da71402c1c3008d5230b106823325.woff2) format("woff2"), url(/static/ubuntu-mono-latin-700italic-029253f5df54bcae6c89c1a8694dd717.woff) format("woff")
        }

        a,
        abbr,
        acronym,
        address,
        applet,
        article,
        aside,
        audio,
        b,
        big,
        blockquote,
        body,
        canvas,
        caption,
        center,
        cite,
        code,
        dd,
        del,
        details,
        dfn,
        div,
        dl,
        dt,
        em,
        embed,
        fieldset,
        figcaption,
        figure,
        footer,
        form,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        header,
        hgroup,
        html,
        i,
        iframe,
        img,
        ins,
        kbd,
        label,
        legend,
        li,
        mark,
        menu,
        nav,
        object,
        ol,
        output,
        p,
        pre,
        q,
        ruby,
        s,
        samp,
        section,
        small,
        span,
        strike,
        strong,
        sub,
        summary,
        sup,
        table,
        tbody,
        td,
        tfoot,
        th,
        thead,
        time,
        tr,
        tt,
        u,
        ul,
        var,
        video {
            border: 0;
            font-size: 100%;
            font: inherit;
            margin: 0;
            padding: 0;
            vertical-align: baseline
        }

        article,
        aside,
        details,
        figcaption,
        figure,
        footer,
        header,
        hgroup,
        menu,
        nav,
        section {
            display: block
        }

        body {
            line-height: 1
        }

        ol,
        ul {
            list-style: none
        }

        blockquote,
        q {
            quotes: none
        }

        blockquote:after,
        blockquote:before,
        q:after,
        q:before {
            content: "";
            content: none
        }

        table {
            border-collapse: collapse;
            border-spacing: 0
        }

        body {
            --white: #fff;
            --white-rgb: 255, 255, 255;
            --platinum: #e3e3e3;
            --chinese-silver: #ccc;
            --davys-grey: #5c5c5c;
            --dark-charcoal: #333;
            --dark-charcoal-rgb: 51, 51, 51;
            --jordy-blue: #85a9f7;
            --cerulean-blue: #2855b7;
            --background: var(--white);
            --background-rgb: var(--white-rgb);
            --focus-border: var(--davys-grey);
            --focus-border-shade-1: var(--chinese-silver);
            --foreground: var(--dark-charcoal);
            --foreground-shade-1: var(--davys-grey);
            --link: var(--cerulean-blue);
            --code-block-background: #161821;
            --code-block-foreground: #c6c8d1;
            --code-block-foreground-shade-1: #84a0c6;
            --blockquote-background: var(--platinum);
            --input-foreground: var(--foreground);
            --input-placeholder: var(--foreground-shade-1);
            --input-icon: var(--foreground);
            --radio-background: var(--background);
            --radio-foreground: var(--foreground);
            --radio-border: var(--foreground);
            --standard-space: 1rem;
            --small-space: calc(var(--standard-space)/2);
            --smallest-space: calc(var(--small-space)/2);
            --large-space: calc(var(--standard-space)*2);
            --largest-space: calc(var(--large-space)*2);
            --standard-font-family: "Source Sans Pro", sans-serif;
            --code-font-family: "Ubuntu Mono", monospace;
            --line-height: 1.5;
            --small-font-size: 10px;
            --standard-font-size: 16px;
            --large-font-size: 1.25rem;
            --largest-font-size: 2rem;
            --standard-border-radius: 5px;
            --large-border-radius: 10px;
            --standard-page-width: 80rem;
            --large-page-width: 120rem
        }

        body.dark {
            --background: var(--dark-charcoal);
            --background-rgb: var(--dark-charcoal-rgb);
            --focus-border: var(--white);
            --focus-border-shade-1: var(--chinese-silver);
            --foreground: var(--white);
            --foreground-shade-1: var(--chinese-silver);
            --link: var(--jordy-blue);
            --code-block-background: #e8e9ec;
            --code-block-foreground: #33374c;
            --code-block-foreground-shade-1: #2d539e;
            --blockquote-background: var(--davys-grey)
        }

        #___gatsby,
        body,
        html {
            height: 100%;
            margin: 0;
            padding: 0
        }

        #gatsby-focus-wrapper {
            align-items: center;
            display: flex;
            flex-direction: column;
            min-height: 100%;
            overflow-x: hidden;
            padding: 0 var(--standard-space)
        }

        #gatsby-focus-wrapper>* {
            flex-shrink: 0;
            max-width: 100%;
            width: var(--standard-page-width)
        }

        body {
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
            background: var(--background);
            color: var(--foreground);
            font-family: var(--standard-font-family);
            font-size: var(--standard-font-size);
            line-height: var(--line-height)
        }

        * {
            -webkit-font-smoothing: antialiased
        }

        a {
            color: var(--foreground);
            font-size: inherit;
            text-decoration: none
        }

        b {
            font-weight: 700
        }

        button {
            background: none;
            border: none;
            color: inherit;
            cursor: pointer;
            font-family: var(--standard-font-family);
            font-size: var(--standard-font-size);
            margin: 0;
            padding: 0
        }

        button:focus,
        button:hover {
            border: none;
            outline: none
        }

        .subtitle {
            font-size: var(--large-font-size)
        }

        .title {
            font-size: var(--largest-font-size);
            font-weight: 700
        }

        .inline-link {
            color: var(--link)
        }

        [data-focusable=true] {
            margin: calc(var(--standard-space)*-1);
            padding: var(--standard-space)
        }

        @media(hover:hover)and (pointer:fine) {
            [data-focusable=true]:hover {
                border-radius: 0;
                box-shadow: 0 2px 0 0 var(--focus-border)
            }

            [data-focusable=true]:focus {
                border-radius: var(--standard-border-radius);
                box-shadow: 0 0 0 2px var(--focus-border);
                outline: none
            }
        }

        @media screen and (min-width:768px) {
            #gatsby-focus-wrapper {
                padding: 0 var(--large-space)
            }
        }

        code,
        pre {
            font-family: var(--code-font-family);
            outline: 0
        }

        .actions {
            position: relative
        }

        .actions__shadow-overlay {
            background: var(--background);
            background: linear-gradient(to right, rgba(var(--background-rgb), 0), rgba(var(--background-rgb), 1));
            display: block;
            height: 100%;
            position: absolute;
            right: 0;
            transition: background .3s ease;
            width: var(--largest-space);
            z-index: 1
        }

        .actions__shadow-overlay-block {
            margin-left: var(--largest-space);
            padding: 1px
        }

        .actions__list {
            align-items: center;
            column-gap: var(--standard-space);
            display: flex;
            overflow-x: auto;
            padding: var(--small-space) 0
        }

        .actions__action {
            cursor: pointer;
            padding: var(--standard-space);
            position: relative;
            white-space: nowrap
        }

        .actions__action--active {
            box-shadow: 0 2px 0 0 var(--focus-border)
        }

        .actions__action>a:after {
            bottom: 0;
            content: "";
            left: 0;
            position: absolute;
            right: 0;
            top: 0;
            z-index: 10
        }

        .actions__action>a:hover {
            box-shadow: none
        }

        .actions__action>a:focus {
            border: none;
            box-shadow: none;
            outline: none;
            text-decoration: underline
        }

        @media(hover:hover)and (pointer:fine) {
            .actions__action:focus-within {
                border-radius: var(--standard-border-radius);
                box-shadow: 0 0 0 2px var(--focus-border);
                outline: none
            }
        }

        @media(hover:hover)and (pointer:fine) {
            .actions__action:hover {
                border-radius: 0;
                box-shadow: 0 2px 0 0 var(--focus-border)
            }
        }

        .actions__action:focus-within a {
            border: none;
            box-shadow: none;
            outline: none;
            text-decoration: none
        }

        @media screen and (min-width:576px) {
            .actions__list {
                justify-content: flex-end;
                padding-right: 0
            }

            .actions__shadow-overlay,
            .actions__shadow-overlay-block {
                display: none
            }
        }

        @media screen and (min-width:768px) {
            .actions__list {
                align-items: unset;
                flex-wrap: wrap;
                margin: var(--standard-space) calc(var(--standard-space)*-1);
                overflow-x: unset;
                padding: 0
            }
        }

        .gutter {
            align-items: center;
            display: flex;
            flex-direction: column;
            left: 0;
            padding: .5em 0;
            position: absolute;
            text-align: right;
            width: 2em
        }

        .gutter__number {
            padding: 0 .5em;
            width: 1em
        }

        .buffer {
            column-gap: var(--small-space);
            display: flex;
            position: relative
        }

        .buffer__code {
            overflow-x: auto;
            padding: .5em .5em .5em 2.5em;
            width: 100%
        }

        .status-line {
            display: flex;
            height: 1.5625em;
            justify-content: space-between;
            max-width: 100%;
            overflow: hidden
        }

        .status-line__content {
            align-items: center;
            display: flex
        }

        .status-line__content>* {
            padding: 0 var(--small-space)
        }

        .status-line__mode {
            align-items: center;
            display: flex;
            height: 100%;
            width: -webkit-min-content;
            width: min-content
        }

        .status-line__extension {
            display: none
        }

        @media screen and (min-width:768px) {
            .status-line__extension {
                display: inline-block
            }
        }

        .code {
            font-family: var(--code-font-family);
            line-height: 1.25
        }

        .home-link {
            align-items: center;
            column-gap: var(--small-space);
            display: flex;
            font-size: var(--large-font-size)
        }

        .home-link__logo {
            height: 2.5em;
            width: auto
        }

        .home-link__title {
            color: var(--foreground-shade-1)
        }

        .home-link__title>span:first-child {
            color: var(--foreground)
        }

        @media screen and (min-width:992px) {
            .home-link {
                font-size: var(--largest-font-size)
            }
        }

        .vimrc__content {
            display: flex;
            flex-direction: column
        }

        button.vimrc__button {
            --border-color: var(--vim-vimCommand, var(--vim-vimOper, var(--normal-fg)));
            align-items: center;
            background: none;
            border: none;
            color: inherit;
            column-gap: .1rem;
            cursor: pointer;
            display: inline-flex;
            font-family: var(--standard-font-family);
            font-family: var(--code-font-family);
            font-size: var(--standard-font-size);
            font-size: inherit;
            margin: 0;
            margin: calc(var(--smallest-space)*-1);
            padding: 0;
            padding: 0 var(--smallest-space)
        }

        button.vimrc__button:focus,
        button.vimrc__button:hover {
            border: none;
            outline: none
        }

        @media(hover:hover)and (pointer:fine) {
            button.vimrc__button:hover {
                box-shadow: 0 2px 0 0 var(--border-color)
            }

            button.vimrc__button:focus {
                border-radius: var(--standard-border-radius);
                box-shadow: 0 0 0 2px var(--border-color);
                outline: none
            }
        }

        .vimrc__button-icon {
            height: 1em;
            width: 1em
        }

        .footer {
            padding: var(--large-space) 0
        }

        .footer__content {
            align-items: center;
            display: flex;
            flex-direction: column;
            gap: var(--large-space)
        }

        .footer__content>:first-child {
            flex: 1 1
        }

        .footer__links {
            column-gap: calc(var(--standard-space)*3);
            justify-content: space-around;
            width: 100%
        }

        .footer__link,
        .footer__links {
            align-items: center;
            display: flex
        }

        .footer__link {
            column-gap: var(--smallest-space)
        }

        .footer__link--accent {
            color: var(--link)
        }

        .footer__link-extension {
            display: none
        }

        @media screen and (min-width:768px) {
            .footer__content {
                flex-direction: row;
                gap: calc(var(--standard-space)*3);
                justify-content: space-between
            }

            .footer__links {
                justify-content: flex-end
            }

            .footer__link-extension {
                display: inline-block
            }
        }

        .preview {
            background: var(--normal-bg);
            border-radius: var(--large-border-radius);
            box-shadow: 0 5px 15px rgba(0, 0, 0, .35);
            color: var(--normal-fg);
            font-size: var(--standard-font-size);
            line-height: 1.125em;
            overflow: hidden
        }

        .preview--dark {
            --normal-fg: var(--vim-NormalFg, #fff);
            --normal-bg: var(--vim-NormalBg, #000)
        }

        .preview--light {
            --normal-fg: var(--vim-NormalFg, #000);
            --normal-bg: var(--vim-NormalBg, #fff)
        }

        .preview__header {
            align-items: center;
            background: var(--vim-StatusLineFg, var(--normal-fg));
            color: var(--vim-StatusLineBg, var(--normal-bg));
            display: flex;
            font-weight: 700;
            height: 1.875em;
            justify-content: center;
            position: relative
        }

        .preview__header>div {
            border-radius: 50%;
            height: .8125em;
            left: var(--small-space);
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: .8125em
        }

        .preview__header>div:first-child {
            background: #ff605c;
            margin-left: 0
        }

        .preview__header>div:nth-child(2) {
            background: #ffbd44;
            margin-left: 1.3125em
        }

        .preview__header>div:nth-child(3) {
            background: #00ca4e;
            margin-left: 2.625em
        }

        .preview__header-file-name {
            left: 50%;
            position: absolute;
            transform: translateX(-50%)
        }

        .preview__header-type {
            position: absolute;
            right: var(--small-space)
        }

        .preview>* {
            margin: 0
        }

        .NormalBg {
            background: var(--normal-bg)
        }

        .CursorFg {
            color: var(--vim-CursorFg, rgba(0, 0, 0, .5))
        }

        .CursorBg {
            background: var(--vim-CursorBg, hsla(0, 0%, 100%, .5))
        }

        .StatusLineFg {
            color: var(--vim-StatusLineFg)
        }

        .StatusLineBg {
            background: var(--vim-StatusLineBg)
        }

        .StatusLineFg--inverted {
            color: var(--vim-StatusLineBg, var(--normal-bg))
        }

        .StatusLineBg--inverted {
            background: var(--vim-StatusLineFg, var(--normal-fg))
        }

        .LineNrFg {
            color: var(--vim-LineNrFg)
        }

        .LineNrBg {
            background: var(--vim-LineNrBg, var(--vim-NormalBg))
        }

        .CursorLineFg {
            color: var(--vim-CursorLineFg, var(--vim-LineNrFg))
        }

        .CursorLineBg {
            background: var(--vim-CursorLineBg, var(--vim-LineNrBg))
        }

        .CursorLineNrFg {
            color: var(--vim-CursorLineNrFg, var(--vim-LineNrFg))
        }

        .CursorLineNrBg {
            background: var(--vim-CursorLineNrBg, var(--vim-LineNrBg))
        }

        .vimLineComment {
            color: var(--vim-vimLineComment);
            font-style: italic
        }

        .vimCommand {
            color: var(--vim-vimCommand)
        }

        .vimFunction {
            color: var(--vim-vimFunction)
        }

        .vimParenSep {
            color: var(--vim-vimParenSep)
        }

        .vimOperParen {
            color: var(--vim-vimOperParen)
        }

        .vimFuncBody {
            color: var(--vim-vimFuncBody)
        }

        .vimIsCommand {
            color: var(--vim-vimIsCommand)
        }

        .vimLet {
            color: var(--vim-vimLet)
        }

        .vimVar {
            color: var(--vim-vimVar)
        }

        .vimOper {
            color: var(--vim-vimOper)
        }

        .vimFuncName {
            color: var(--vim-vimFuncName)
        }

        .vimFuncVar {
            color: var(--vim-vimFuncVar)
        }

        .vimString {
            color: var(--vim-vimString)
        }

        .vimSubst {
            color: var(--vim-vimSubst)
        }

        .vimNumber {
            color: var(--vim-vimNumber)
        }

        .vimNotFunc {
            color: var(--vim-vimNotFunc)
        }

        .preview-page {
            height: 627px !important;
            position: relative;
            width: 1200px !important
        }

        .preview-page__preview-container {
            left: 50%;
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%)
        }

        .preview-page__preview {
            box-shadow: 0 22px 70px 4px rgba(0, 0, 0, .56);
            font-size: var(--large-font-size)
        }

        .preview-page--gallery .preview-page__preview {
            font-size: var(--standard-font-size)
        }

        .pill {
            align-items: center;
            border: 1px solid var(--focus-border);
            color: var(--foreground);
            display: inline-block;
            display: flex;
            height: 1rem;
            justify-content: center;
            padding: var(--smallest-space) var(--small-space)
        }

        .background-switch,
        .pill {
            border-radius: var(--standard-border-radius)
        }

        .background-switch {
            background: var(--code-block-background);
            color: var(--code-block-foreground);
            cursor: pointer;
            font-family: var(--code-font-family);
            font-size: var(--large-font-size);
            line-height: 1.25;
            padding: 1rem;
            position: relative
        }

        .background-switch:focus,
        .background-switch:hover {
            box-shadow: none;
            outline: none
        }

        .background-switch__input {
            opacity: 0;
            pointer-events: none;
            position: absolute
        }

        .background-switch__indicator {
            margin: calc(var(--smallest-space)*-1);
            padding: var(--smallest-space)
        }

        .background-switch__indicator-operator {
            color: var(--code-block-foreground-shade-1)
        }

        .background-switch:hover .background-switch__indicator {
            box-shadow: 0 2px 0 0 var(--code-block-foreground-shade-1)
        }

        @media(hover:hover)and (pointer:fine) {
            .background-switch__input:focus~* .background-switch__indicator {
                border-radius: var(--standard-border-radius);
                box-shadow: 0 0 0 2px var(--code-block-foreground-shade-1)
            }
        }

        .background-switch__background-label,
        .background-switch__indicator-operator {
            display: none
        }

        @media screen and (min-width:768px) {

            .background-switch__background-label,
            .background-switch__indicator-operator {
                display: inline-block
            }
        }

        .meta {
            row-gap: var(--standard-space)
        }

        .meta,
        .meta-header {
            display: flex;
            flex-direction: column
        }

        .meta-header {
            margin-bottom: var(--small-space);
            row-gap: var(--small-space)
        }

        .meta-header__row {
            align-items: center;
            display: flex;
            justify-content: space-between;
            line-height: 1.25rem
        }

        .meta-header__statistic {
            align-items: center;
            column-gap: var(--smallest-space);
            display: flex
        }

        .meta-header__icon {
            line-height: 1.25rem
        }

        .meta-footer {
            align-items: flex-end;
            column-gap: var(--standard-space);
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between
        }

        .meta-footer__column {
            display: flex;
            flex-direction: column;
            row-gap: var(--smallest-space)
        }

        .meta-footer__row {
            line-height: 1.25rem
        }

        .meta-footer__pills {
            align-items: center;
            column-gap: var(--smallest-space);
            display: flex
        }

        .card {
            display: flex;
            flex-direction: column;
            margin: calc(var(--standard-space)*-1);
            padding: var(--standard-space);
            position: relative;
            row-gap: var(--standard-space)
        }

        @media(hover:hover)and (pointer:fine) {
            .card:hover {
                border-radius: 0;
                box-shadow: 0 2px 0 0 var(--focus-border)
            }
        }

        @media(hover:hover)and (pointer:fine) {
            .card:focus-within {
                border-radius: var(--standard-border-radius);
                box-shadow: 0 0 0 2px var(--focus-border);
                outline: none
            }
        }

        .card__ghost-link {
            height: 75%;
            left: 50%;
            opacity: 0;
            padding: 0;
            pointer-events: none;
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 0
        }

        .card__link {
            margin: calc(var(--small-space)*-1);
            padding: var(--small-space)
        }

        @media(hover:hover)and (pointer:fine) {
            .card__link:focus {
                border-radius: var(--standard-border-radius);
                box-shadow: 0 0 0 2px var(--focus-border-shade-1);
                outline: none
            }
        }

        .filters {
            column-gap: var(--standard-space)
        }

        .filters,
        .filters__inputs {
            align-items: center;
            display: flex
        }

        .filters__inputs {
            column-gap: var(--large-space);
            margin: calc(var(--standard-space)*-1);
            padding: var(--standard-space)
        }

        @media(hover:hover)and (pointer:fine) {
            .filters__inputs:hover {
                border-radius: 0;
                box-shadow: 0 2px 0 0 var(--focus-border)
            }
        }

        @media(hover:hover)and (pointer:fine) {
            .filters__inputs:focus-within {
                border-radius: var(--standard-border-radius);
                box-shadow: 0 0 0 2px var(--focus-border);
                outline: none
            }
        }

        .filters__input-container {
            align-items: center;
            column-gap: var(--small-space);
            cursor: pointer;
            display: flex;
            margin: calc(var(--standard-space)*-1);
            padding: var(--standard-space);
            position: relative
        }

        .filters__input-container>svg {
            width: 1.5625rem
        }

        .filters__input {
            left: 0;
            opacity: 0;
            position: absolute;
            top: 0
        }

        .grid {
            display: grid;
            gap: var(--largest-space);
            grid-template-columns: 100%;
            width: 100%
        }

        @media screen and (min-width:992px) {
            .grid {
                grid-template-columns: minmax(0, 1fr) minmax(0, 1fr)
            }
        }

        .header {
            align-items: center;
            column-gap: var(--standard-space);
            display: flex;
            justify-content: space-between;
            padding: var(--large-space) 0
        }

        .main {
            flex: 1 1;
            padding: var(--standard-space)
        }

        .icon-arrow--left {
            transform: rotate(180deg)
        }

        .pagination {
            column-gap: var(--standard-space);
            justify-content: space-between;
            margin-top: var(--large-space);
            max-width: 100%;
            width: var(--standard-page-width)
        }

        .pagination,
        .pagination>div {
            align-items: center;
            display: flex
        }

        .pagination>div {
            flex: 1 1;
            justify-content: center
        }

        .pagination>div:first-child {
            justify-content: flex-start
        }

        .pagination>div:last-child {
            justify-content: flex-end
        }

        .pagination__link {
            align-items: center;
            column-gap: var(--smallest-space);
            display: flex
        }

        .pagination__icon {
            height: 1.2rem
        }

        #gatsby-focus-wrapper>.about {
            width: 40rem
        }

        .about h1,
        .about h2,
        .about h3,
        .about p {
            margin-bottom: var(--standard-space)
        }

        .about h1,
        .about h2,
        .about h3 {
            font-weight: 700;
            margin-top: var(--large-space)
        }

        .about ul {
            padding-left: var(--large-space)
        }

        .about li {
            list-style: disc
        }

        .about blockquote {
            background: var(--blockquote-background);
            border-radius: var(--standard-border-radius);
            margin: 1rem 0;
            padding: var(--standard-space)
        }

        .icon-forward-slash {
            transform: rotate(-28deg)
        }

        .search-input {
            align-items: center;
            display: flex;
            position: relative
        }

        .search-input__overlay-button {
            background: none;
            border: none;
            bottom: 0;
            cursor: pointer;
            left: 0;
            outline: none;
            position: absolute;
            right: 0;
            top: 0;
            width: calc(100% + var(--standard-space)*2);
            z-index: -1
        }

        .search-input__overlay-button:focus,
        .search-input__overlay-button:hover {
            border: none;
            box-shadow: none;
            outline: none
        }

        .search-input__input-wrapper {
            border-bottom: 2px solid var(--focus-border);
            flex: 1 1;
            position: relative
        }

        @media(hover:hover)and (pointer:fine) {
            .search-input__input-wrapper:focus-within {
                border-bottom: 2px solid var(--focus-border)
            }
        }

        .search-input__input {
            background: transparent;
            border: none;
            color: var(--input-foreground);
            flex: 1 1;
            font-size: var(--standard-font-size);
            outline: none;
            padding: var(--small-space);
            width: calc(100% - var(--standard-space)*2)
        }

        .search-input__input::placeholder {
            color: var(--input-placeholder)
        }

        .search-input__icon {
            color: var(--input-icon);
            height: var(--standard-space);
            width: var(--standard-space)
        }

        .search-input__icon--short {
            height: calc(var(--standard-space)*.9);
            width: calc(var(--standard-space)*.9)
        }

        .search-input__icon-wrapper {
            align-items: center;
            display: flex;
            justify-content: center;
            left: 100%;
            position: absolute;
            top: 50%;
            transform: translate(-100%, -50%)
        }

        @media screen and (min-width:992px) {
            .search-input {
                width: 15rem
            }
        }

        @media screen and (min-width:992px)and (hover:hover)and (pointer:fine) {
            .search-input__overlay-button:focus {
                box-shadow: 0 0 0 2px var(--focus-border)
            }
        }

        #gatsby-focus-wrapper>.repositories {
            max-width: 100%;
            width: var(--large-page-width)
        }

        .repositories {
            align-items: center;
            display: flex;
            flex-direction: column;
            padding-top: 0;
            row-gap: var(--large-space)
        }

        .repositories__header {
            display: flex;
            flex-direction: column;
            gap: var(--large-space);
            max-width: 100%;
            width: var(--standard-page-width)
        }

        .repositories__header-row {
            display: flex;
            flex-direction: column-reverse;
            gap: var(--large-space)
        }

        .repositories__header-row--align-end {
            align-items: flex-end
        }

        .repositories__search-indicator {
            width: 100%
        }

        @media screen and (min-width:992px) {
            .repositories__header-row {
                align-items: center;
                flex-direction: row;
                justify-content: space-between
            }

            .repositories__header-row--align-end {
                align-items: center;
                justify-content: flex-end
            }
        }

        .repository__content {
            align-items: center;
            display: flex;
            flex-direction: column;
            row-gap: var(--large-space)
        }

        .repository__nav {
            align-items: center;
            display: flex;
            justify-content: space-between;
            margin: var(--standard-space) 0;
            width: 100%
        }

        .repository__meta {
            margin: 0;
            width: 100%
        }

        .repository__link {
            align-items: center;
            column-gap: var(--smallest-space);
            display: flex
        }

        .repository__link-icon {
            height: 1.2rem
        }

        .repository__previews {
            align-items: center;
            display: flex;
            flex-direction: column;
            margin: var(--standard-space) 0 var(--largest-space);
            row-gap: var(--large-space);
            width: 100%
        }

        .repository__previews>* {
            width: 100%
        }

        .repository__previews-title {
            text-align: center
        }

        .repository__preview {
            font-size: var(--standard-font-size);
            margin: var(--standard-space) 0;
            max-width: 56.25rem;
            width: 100%
        }

        .repository__link-extension {
            display: none
        }

        @media screen and (min-width:768px) {
            .repository__link-extension {
                display: inline-block
            }

            .repository__preview {
                font-size: var(--large-font-size);
                margin: var(--large-space) 0
            }
        }
    </style>
    <link rel="sitemap" type="application/xml" href="/sitemap-index.xml" />
    <link rel="icon" href="/favicon-32x32.png?v=2aab5d937d130055518d9642ef941b98" type="image/png" />
    <link rel="manifest" href="/manifest.webmanifest" crossorigin="anonymous" />
    <link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=2aab5d937d130055518d9642ef941b98" />
    <link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=2aab5d937d130055518d9642ef941b98" />
    <link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=2aab5d937d130055518d9642ef941b98" />
    <link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=2aab5d937d130055518d9642ef941b98" />
    <link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=2aab5d937d130055518d9642ef941b98" />
    <link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=2aab5d937d130055518d9642ef941b98" />
    <link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=2aab5d937d130055518d9642ef941b98" />
    <link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=2aab5d937d130055518d9642ef941b98" />
    <title data-gatsby-head="true">doki-theme-vim, by doki-theme | vimcolorschemes</title>
</head>

<body class="light">
    <script type="text/javascript">/* Spatial Navigation Polyfill
*
* It follows W3C official specification
* https://drafts.csswg.org/css-nav-1/
*
* Copyright (c) 2018-2019 LG Electronics Inc.
* https://github.com/WICG/spatial-navigation/polyfill
*
* Licensed under the MIT license (MIT)
*/

        (function () {

            // The polyfill must not be executed, if it's already enabled via browser engine or browser extensions.
            if ('navigate' in window) {
                return;
            }

            const ARROW_KEY_CODE = { 37: 'left', 38: 'up', 39: 'right', 40: 'down' };
            const TAB_KEY_CODE = 9;
            let mapOfBoundRect = null;
            let startingPoint = null; // Saves spatial navigation starting point
            let savedSearchOrigin = { element: null, rect: null };  // Saves previous search origin
            let searchOriginRect = null;  // Rect of current search origin

            /**
             * Initiate the spatial navigation features of the polyfill.
             * @function initiateSpatialNavigation
             */
            function initiateSpatialNavigation() {
                /*
                 * Bind the standards APIs to be exposed to the window object for authors
                 */
                window.navigate = navigate;
                window.Element.prototype.spatialNavigationSearch = spatialNavigationSearch;
                window.Element.prototype.focusableAreas = focusableAreas;
                window.Element.prototype.getSpatialNavigationContainer = getSpatialNavigationContainer;

                /*
                 * CSS.registerProperty() from the Properties and Values API
                 * Reference: https://drafts.css-houdini.org/css-properties-values-api/#the-registerproperty-function
                 */
                if (window.CSS && CSS.registerProperty) {
                    if (window.getComputedStyle(document.documentElement).getPropertyValue('--spatial-navigation-contain') === '') {
                        CSS.registerProperty({
                            name: '--spatial-navigation-contain',
                            syntax: 'auto | contain',
                            inherits: false,
                            initialValue: 'auto'
                        });
                    }

                    if (window.getComputedStyle(document.documentElement).getPropertyValue('--spatial-navigation-action') === '') {
                        CSS.registerProperty({
                            name: '--spatial-navigation-action',
                            syntax: 'auto | focus | scroll',
                            inherits: false,
                            initialValue: 'auto'
                        });
                    }

                    if (window.getComputedStyle(document.documentElement).getPropertyValue('--spatial-navigation-function') === '') {
                        CSS.registerProperty({
                            name: '--spatial-navigation-function',
                            syntax: 'normal | grid',
                            inherits: false,
                            initialValue: 'normal'
                        });
                    }
                }
            }

            /**
             * Add event handlers for the spatial navigation behavior.
             * This function defines which input methods trigger the spatial navigation behavior.
             * @function spatialNavigationHandler
             */
            function spatialNavigationHandler() {
                /*
                 * keydown EventListener :
                 * If arrow key pressed, get the next focusing element and send it to focusing controller
                 */
                window.addEventListener('keydown', (e) => {
                    const currentKeyMode = (parent && parent.__spatialNavigation__.keyMode) || window.__spatialNavigation__.keyMode;
                    const eventTarget = document.activeElement;
                    const dir = ARROW_KEY_CODE[e.keyCode];

                    if (e.keyCode === TAB_KEY_CODE) {
                        startingPoint = null;
                    }

                    if (!currentKeyMode ||
                        (currentKeyMode === 'NONE') ||
                        ((currentKeyMode === 'SHIFTARROW') && !e.shiftKey) ||
                        ((currentKeyMode === 'ARROW') && e.shiftKey))
                        return;

                    if (!e.defaultPrevented) {
                        let focusNavigableArrowKey = { left: true, up: true, right: true, down: true };

                        // Edge case (text input, area) : Don't move focus, just navigate cursor in text area
                        if ((eventTarget.nodeName === 'INPUT') || eventTarget.nodeName === 'TEXTAREA') {
                            focusNavigableArrowKey = handlingEditableElement(e);
                        }

                        if (focusNavigableArrowKey[dir]) {
                            e.preventDefault();
                            mapOfBoundRect = new Map();

                            navigate(dir);

                            mapOfBoundRect = null;
                            startingPoint = null;
                        }
                    }
                });

                /*
                 * mouseup EventListener :
                 * If the mouse click a point in the page, the point will be the starting point.
                 * NOTE: Let UA set the spatial navigation starting point based on click
                 */
                document.addEventListener('mouseup', (e) => {
                    startingPoint = { x: e.clientX, y: e.clientY };
                });

                /*
                 * focusin EventListener :
                 * When the element get the focus, save it and its DOMRect for resetting the search origin
                 * if it disappears.
                 */
                window.addEventListener('focusin', (e) => {
                    if (e.target !== window) {
                        savedSearchOrigin.element = e.target;
                        savedSearchOrigin.rect = e.target.getBoundingClientRect();
                    }
                });
            }

            /**
             * Enable the author to trigger spatial navigation programmatically, as if the user had done so manually.
             * @see {@link https://drafts.csswg.org/css-nav-1/#dom-window-navigate}
             * @function navigate
             * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
             */
            function navigate(dir) {
                // spatial navigation steps

                // 1
                const searchOrigin = findSearchOrigin();
                let eventTarget = searchOrigin;

                let elementFromPosition = null;

                // 2 Optional step, UA defined starting point
                if (startingPoint) {
                    // if there is a starting point, set eventTarget as the element from position for getting the spatnav container
                    elementFromPosition = document.elementFromPoint(startingPoint.x, startingPoint.y);

                    // Use starting point if the starting point isn't inside the focusable element (but not container)
                    // * Starting point is meaningfull when:
                    // 1) starting point is inside the spatnav container
                    // 2) starting point is inside the non-focusable element
                    if (elementFromPosition === null) {
                        elementFromPosition = document.body;
                    }
                    if (isFocusable(elementFromPosition) && !isContainer(elementFromPosition)) {
                        startingPoint = null;
                    } else if (isContainer(elementFromPosition)) {
                        eventTarget = elementFromPosition;
                    } else {
                        eventTarget = elementFromPosition.getSpatialNavigationContainer();
                    }
                }

                // 4
                if (eventTarget === document || eventTarget === document.documentElement) {
                    eventTarget = document.body || document.documentElement;
                }

                // 5
                // At this point, spatialNavigationSearch can be applied.
                // If startingPoint is either a scroll container or the document,
                // find the best candidate within startingPoint
                let container = null;
                if ((isContainer(eventTarget) || eventTarget.nodeName === 'BODY') && !(eventTarget.nodeName === 'INPUT')) {
                    if (eventTarget.nodeName === 'IFRAME') {
                        eventTarget = eventTarget.contentDocument.documentElement;
                    }
                    container = eventTarget;
                    let bestInsideCandidate = null;

                    // 5-2
                    if ((document.activeElement === searchOrigin) ||
                        (document.activeElement === document.body) && (searchOrigin === document.documentElement)) {
                        if (getCSSSpatNavAction(eventTarget) === 'scroll') {
                            if (scrollingController(eventTarget, dir)) return;
                        } else if (getCSSSpatNavAction(eventTarget) === 'focus') {
                            bestInsideCandidate = eventTarget.spatialNavigationSearch(dir, { container: eventTarget, candidates: getSpatialNavigationCandidates(eventTarget, { mode: 'all' }) });
                            if (focusingController(bestInsideCandidate, dir)) return;
                        } else if (getCSSSpatNavAction(eventTarget) === 'auto') {
                            bestInsideCandidate = eventTarget.spatialNavigationSearch(dir, { container: eventTarget });
                            if (focusingController(bestInsideCandidate, dir) || scrollingController(eventTarget, dir)) return;
                        }
                    } else {
                        // when the previous search origin became offscreen
                        container = container.getSpatialNavigationContainer();
                    }
                }

                // 6
                // Let container be the nearest ancestor of eventTarget
                container = eventTarget.getSpatialNavigationContainer();
                let parentContainer = (container.parentElement) ? container.getSpatialNavigationContainer() : null;

                // When the container is the viewport of a browsing context
                if (!parentContainer && (window.location !== window.parent.location)) {
                    parentContainer = window.parent.document.documentElement;
                }

                if (getCSSSpatNavAction(container) === 'scroll') {
                    if (scrollingController(container, dir)) return;
                } else if (getCSSSpatNavAction(container) === 'focus') {
                    navigateChain(eventTarget, container, parentContainer, dir, 'all');
                } else if (getCSSSpatNavAction(container) === 'auto') {
                    navigateChain(eventTarget, container, parentContainer, dir, 'visible');
                }
            }

            /**
             * Move the focus to the best candidate or do nothing.
             * @function focusingController
             * @param bestCandidate {Node} - The best candidate of the spatial navigation
             * @param dir {SpatialNavigationDirection}- The directional information for the spatial navigation (e.g. LRUD)
             * @returns {boolean}
             */
            function focusingController(bestCandidate, dir) {
                // 10 & 11
                // When bestCandidate is found
                if (bestCandidate) {
                    // When bestCandidate is a focusable element and not a container : move focus
                    /*
                     * [event] navbeforefocus : Fired before spatial or sequential navigation changes the focus.
                     */
                    if (!createSpatNavEvents('beforefocus', bestCandidate, null, dir))
                        return true;

                    const container = bestCandidate.getSpatialNavigationContainer();

                    if ((container !== window) && (getCSSSpatNavAction(container) === 'focus')) {
                        bestCandidate.focus();
                    } else {
                        bestCandidate.focus({ preventScroll: true });
                    }

                    startingPoint = null;
                    return true;
                }

                // When bestCandidate is not found within the scrollport of a container: Nothing
                return false;
            }

            /**
             * Directionally scroll the scrollable spatial navigation container if it can be manually scrolled more.
             * @function scrollingController
             * @param container {Node} - The spatial navigation container which can scroll
             * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
             * @returns {boolean}
             */
            function scrollingController(container, dir) {

                // If there is any scrollable area among parent elements and it can be manually scrolled, scroll the document
                if (isScrollable(container, dir) && !isScrollBoundary(container, dir)) {
                    moveScroll(container, dir);
                    return true;
                }

                // If the spatnav container is document and it can be scrolled, scroll the document
                if (!container.parentElement && !isHTMLScrollBoundary(container, dir)) {
                    moveScroll(container.ownerDocument.documentElement, dir);
                    return true;
                }
                return false;
            }

            /**
             * Find the candidates within a spatial navigation container include delegable container.
             * This function does not search inside delegable container or focusable container.
             * In other words, this return candidates set is not included focusable elements inside delegable container or focusable container.
             *
             * @function getSpatialNavigationCandidates
             * @param container {Node} - The spatial navigation container
             * @param option {FocusableAreasOptions} - 'mode' attribute takes 'visible' or 'all' for searching the boundary of focusable elements.
             *                                          Default value is 'visible'.
             * @returns {sequence<Node>} candidate elements within the container
             */
            function getSpatialNavigationCandidates(container, option = { mode: 'visible' }) {
                let candidates = [];

                if (container.childElementCount > 0) {
                    if (!container.parentElement) {
                        container = container.getElementsByTagName('body')[0] || document.body;
                    }
                    const children = container.children;
                    for (const elem of children) {
                        if (isDelegableContainer(elem)) {
                            candidates.push(elem);
                        } else if (isFocusable(elem)) {
                            candidates.push(elem);

                            if (!isContainer(elem) && elem.childElementCount) {
                                candidates = candidates.concat(getSpatialNavigationCandidates(elem, { mode: 'all' }));
                            }
                        } else if (elem.childElementCount) {
                            candidates = candidates.concat(getSpatialNavigationCandidates(elem, { mode: 'all' }));
                        }
                    }
                }
                return (option.mode === 'all') ? candidates : candidates.filter(isVisible);
            }

            /**
             * Find the candidates among focusable elements within a spatial navigation container from the search origin (currently focused element)
             * depending on the directional information.
             * @function getFilteredSpatialNavigationCandidates
             * @param element {Node} - The currently focused element which is defined as 'search origin' in the spec
             * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
             * @param candidates {sequence<Node>} - The candidates for spatial navigation without the directional information
             * @param container {Node} - The spatial navigation container
             * @returns {Node} The candidates for spatial navigation considering the directional information
             */
            function getFilteredSpatialNavigationCandidates(element, dir, candidates, container) {
                const targetElement = element;
                // Removed below line due to a bug. (iframe body rect is sometime weird.)
                // const targetElement = (element.nodeName === 'IFRAME') ? element.contentDocument.body : element;
                // If the container is unknown, get the closest container from the element
                container = container || targetElement.getSpatialNavigationContainer();

                // If the candidates is unknown, find candidates
                // 5-1
                candidates = (!candidates || candidates.length <= 0) ? getSpatialNavigationCandidates(container) : candidates;
                return filteredCandidates(targetElement, candidates, dir, container);
            }

            /**
             * Find the best candidate among the candidates within the container from the search origin (currently focused element)
             * @see {@link https://drafts.csswg.org/css-nav-1/#dom-element-spatialnavigationsearch}
             * @function spatialNavigationSearch
             * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
             * @param candidates {sequence<Node>} - The candidates for spatial navigation
             * @param container {Node} - The spatial navigation container
             * @returns {Node} The best candidate which will gain the focus
             */
            function spatialNavigationSearch(dir, args) {
                const targetElement = this;
                let internalCandidates = [];
                let externalCandidates = [];
                let insideOverlappedCandidates = getOverlappedCandidates(targetElement);
                let bestTarget;

                // Set default parameter value
                if (!args)
                    args = {};

                const defaultContainer = targetElement.getSpatialNavigationContainer();
                let defaultCandidates = getSpatialNavigationCandidates(defaultContainer);
                const container = args.container || defaultContainer;
                if (args.container && (defaultContainer.contains(args.container))) {
                    defaultCandidates = defaultCandidates.concat(getSpatialNavigationCandidates(container));
                }
                const candidates = (args.candidates && args.candidates.length > 0) ?
                    args.candidates.filter((candidate) => container.contains(candidate)) :
                    defaultCandidates.filter((candidate) => container.contains(candidate) && (container !== candidate));

                // Find the best candidate
                // 5
                // If startingPoint is either a scroll container or the document,
                // find the best candidate within startingPoint
                if (candidates && candidates.length > 0) {

                    // Divide internal or external candidates
                    candidates.forEach(candidate => {
                        if (candidate !== targetElement) {
                            (targetElement.contains(candidate) && targetElement !== candidate ? internalCandidates : externalCandidates).push(candidate);
                        }
                    });

                    // include overlapped element to the internalCandidates
                    let fullyOverlapped = insideOverlappedCandidates.filter(candidate => !internalCandidates.includes(candidate));
                    let overlappedContainer = candidates.filter(candidate => (isContainer(candidate) && isEntirelyVisible(targetElement, candidate)));
                    let overlappedByParent = overlappedContainer.map((elm) => elm.focusableAreas()).flat().filter(candidate => candidate !== targetElement);

                    internalCandidates = internalCandidates.concat(fullyOverlapped).filter((candidate) => container.contains(candidate));
                    externalCandidates = externalCandidates.concat(overlappedByParent).filter((candidate) => container.contains(candidate));

                    // Filter external Candidates
                    if (externalCandidates.length > 0) {
                        externalCandidates = getFilteredSpatialNavigationCandidates(targetElement, dir, externalCandidates, container);
                    }

                    // If there isn't search origin element but search orgin rect exist  (search origin isn't in the layout case)
                    if (searchOriginRect) {
                        bestTarget = selectBestCandidate(targetElement, getFilteredSpatialNavigationCandidates(targetElement, dir, internalCandidates, container), dir);
                    }

                    if ((internalCandidates && internalCandidates.length > 0) && !(targetElement.nodeName === 'INPUT')) {
                        bestTarget = selectBestCandidateFromEdge(targetElement, internalCandidates, dir);
                    }

                    bestTarget = bestTarget || selectBestCandidate(targetElement, externalCandidates, dir);

                    if (bestTarget && isDelegableContainer(bestTarget)) {
                        // if best target is delegable container, then find descendants candidate inside delegable container.
                        const innerTarget = getSpatialNavigationCandidates(bestTarget, { mode: 'all' });
                        const descendantsBest = innerTarget.length > 0 ? targetElement.spatialNavigationSearch(dir, { candidates: innerTarget, container: bestTarget }) : null;
                        if (descendantsBest) {
                            bestTarget = descendantsBest;
                        } else if (!isFocusable(bestTarget)) {
                            // if there is no target inside bestTarget and delegable container is not focusable,
                            // then try to find another best target without curren best target.
                            candidates.splice(candidates.indexOf(bestTarget), 1);
                            bestTarget = candidates.length ? targetElement.spatialNavigationSearch(dir, { candidates: candidates, container: container }) : null;
                        }
                    }
                    return bestTarget;
                }

                return null;
            }

            /**
             * Get the filtered candidate among candidates.
             * @see {@link https://drafts.csswg.org/css-nav-1/#select-the-best-candidate}
             * @function filteredCandidates
             * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec
             * @param candidates {sequence<Node>} - The candidates for spatial navigation
             * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
             * @param container {Node} - The spatial navigation container
             * @returns {sequence<Node>} The filtered candidates which are not the search origin and not in the given spatial navigation direction from the search origin
             */
            // TODO: Need to fix filtering the candidates with more clean code
            function filteredCandidates(currentElm, candidates, dir, container) {
                const originalContainer = currentElm.getSpatialNavigationContainer();
                let eventTargetRect;

                // If D(dir) is null, let candidates be the same as visibles
                if (dir === undefined)
                    return candidates;

                // Offscreen handling when originalContainer is not <HTML>
                if (originalContainer.parentElement && container !== originalContainer && !isVisible(currentElm)) {
                    eventTargetRect = getBoundingClientRect(originalContainer);
                } else {
                    eventTargetRect = searchOriginRect || getBoundingClientRect(currentElm);
                }

                /*
                 * Else, let candidates be the subset of the elements in visibles
                 * whose principal box’s geometric center is within the closed half plane
                 * whose boundary goes through the geometric center of starting point and is perpendicular to D.
                 */
                if ((isContainer(currentElm) || currentElm.nodeName === 'BODY') && !(currentElm.nodeName === 'INPUT')) {
                    return candidates.filter(candidate => {
                        const candidateRect = getBoundingClientRect(candidate);
                        return container.contains(candidate) &&
                            ((currentElm.contains(candidate) && isInside(eventTargetRect, candidateRect) && candidate !== currentElm) ||
                                isOutside(candidateRect, eventTargetRect, dir));
                    });
                } else {
                    return candidates.filter(candidate => {
                        const candidateRect = getBoundingClientRect(candidate);
                        const candidateBody = (candidate.nodeName === 'IFRAME') ? candidate.contentDocument.body : null;
                        return container.contains(candidate) &&
                            candidate !== currentElm && candidateBody !== currentElm &&
                            isOutside(candidateRect, eventTargetRect, dir) &&
                            !isInside(eventTargetRect, candidateRect);
                    });
                }
            }

            /**
             * Select the best candidate among given candidates.
             * @see {@link https://drafts.csswg.org/css-nav-1/#select-the-best-candidate}
             * @function selectBestCandidate
             * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec
             * @param candidates {sequence<Node>} - The candidates for spatial navigation
             * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
             * @returns {Node} The best candidate which will gain the focus
             */
            function selectBestCandidate(currentElm, candidates, dir) {
                const container = currentElm.getSpatialNavigationContainer();
                const spatialNavigationFunction = getComputedStyle(container).getPropertyValue('--spatial-navigation-function');
                const currentTargetRect = searchOriginRect || getBoundingClientRect(currentElm);
                let distanceFunction;
                let alignedCandidates;

                switch (spatialNavigationFunction) {
                    case 'grid':
                        alignedCandidates = candidates.filter(elm => isAligned(currentTargetRect, getBoundingClientRect(elm), dir));
                        if (alignedCandidates.length > 0) {
                            candidates = alignedCandidates;
                        }
                        distanceFunction = getAbsoluteDistance;
                        break;
                    default:
                        distanceFunction = getDistance;
                        break;
                }
                return getClosestElement(currentElm, candidates, dir, distanceFunction);
            }

            /**
             * Select the best candidate among candidates by finding the closet candidate from the edge of the currently focused element (search origin).
             * @see {@link https://drafts.csswg.org/css-nav-1/#select-the-best-candidate (Step 5)}
             * @function selectBestCandidateFromEdge
             * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec
             * @param candidates {sequence<Node>} - The candidates for spatial navigation
             * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
             * @returns {Node} The best candidate which will gain the focus
             */
            function selectBestCandidateFromEdge(currentElm, candidates, dir) {
                if (startingPoint)
                    return getClosestElement(currentElm, candidates, dir, getDistanceFromPoint);
                else
                    return getClosestElement(currentElm, candidates, dir, getInnerDistance);
            }

            /**
             * Select the closest candidate from the currently focused element (search origin) among candidates by using the distance function.
             * @function getClosestElement
             * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec
             * @param candidates {sequence<Node>} - The candidates for spatial navigation
             * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
             * @param distanceFunction {function} - The distance function which measures the distance from the search origin to each candidate
             * @returns {Node} The candidate which is the closest one from the search origin
             */
            function getClosestElement(currentElm, candidates, dir, distanceFunction) {
                let eventTargetRect = null;
                if ((window.location !== window.parent.location) && (currentElm.nodeName === 'BODY' || currentElm.nodeName === 'HTML')) {
                    // If the eventTarget is iframe, then get rect of it based on its containing document
                    // Set the iframe's position as (0,0) because the rects of elements inside the iframe don't know the real iframe's position.
                    eventTargetRect = window.frameElement.getBoundingClientRect();
                    eventTargetRect.x = 0;
                    eventTargetRect.y = 0;
                } else {
                    eventTargetRect = searchOriginRect || currentElm.getBoundingClientRect();
                }

                let minDistance = Number.POSITIVE_INFINITY;
                let minDistanceElements = [];

                if (candidates) {
                    for (let i = 0; i < candidates.length; i++) {
                        const distance = distanceFunction(eventTargetRect, getBoundingClientRect(candidates[i]), dir);

                        // If the same distance, the candidate will be selected in the DOM order
                        if (distance < minDistance) {
                            minDistance = distance;
                            minDistanceElements = [candidates[i]];
                        } else if (distance === minDistance) {
                            minDistanceElements.push(candidates[i]);
                        }
                    }
                }
                if (minDistanceElements.length === 0)
                    return null;

                return (minDistanceElements.length > 1 && distanceFunction === getAbsoluteDistance) ?
                    getClosestElement(currentElm, minDistanceElements, dir, getEuclideanDistance) : minDistanceElements[0];
            }

            /**
             * Get container of an element.
             * @see {@link https://drafts.csswg.org/css-nav-1/#dom-element-getspatialnavigationcontainer}
             * @module Element
             * @function getSpatialNavigationContainer
             * @returns {Node} The spatial navigation container
             */
            function getSpatialNavigationContainer() {
                let container = this;

                do {
                    if (!container.parentElement) {
                        if (window.location !== window.parent.location) {
                            container = window.parent.document.documentElement;
                        } else {
                            container = window.document.documentElement;
                        }
                        break;
                    } else {
                        container = container.parentElement;
                    }
                } while (!isContainer(container));
                return container;
            }

            /**
             * Get nearest scroll container of an element.
             * @function getScrollContainer
             * @param Element
             * @returns {Node} The spatial navigation container
             */
            function getScrollContainer(element) {
                let scrollContainer = element;

                do {
                    if (!scrollContainer.parentElement) {
                        if (window.location !== window.parent.location) {
                            scrollContainer = window.parent.document.documentElement;
                        } else {
                            scrollContainer = window.document.documentElement;
                        }
                        break;
                    } else {
                        scrollContainer = scrollContainer.parentElement;
                    }
                } while (!isScrollContainer(scrollContainer) || !isVisible(scrollContainer));

                if (scrollContainer === document || scrollContainer === document.documentElement) {
                    scrollContainer = window;
                }

                return scrollContainer;
            }

            /**
             * Find focusable elements within the spatial navigation container.
             * @see {@link https://drafts.csswg.org/css-nav-1/#dom-element-focusableareas}
             * @function focusableAreas
             * @param option {FocusableAreasOptions} - 'mode' attribute takes 'visible' or 'all' for searching the boundary of focusable elements.
             *                                          Default value is 'visible'.
             * @returns {sequence<Node>} All focusable elements or only visible focusable elements within the container
             */
            function focusableAreas(option = { mode: 'visible' }) {
                const container = this.parentElement ? this : document.body;
                const focusables = Array.prototype.filter.call(container.getElementsByTagName('*'), isFocusable);
                return (option.mode === 'all') ? focusables : focusables.filter(isVisible);
            }

            /**
             * Create the NavigationEvent: navbeforefocus, navnotarget
             * @see {@link https://drafts.csswg.org/css-nav-1/#events-navigationevent}
             * @function createSpatNavEvents
             * @param option {string} - Type of the navigation event (beforefocus, notarget)
             * @param element {Node} - The target element of the event
             * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
             */
            function createSpatNavEvents(eventType, containerElement, currentElement, direction) {
                if (['beforefocus', 'notarget'].includes(eventType)) {
                    const data = {
                        causedTarget: currentElement,
                        dir: direction
                    };
                    const triggeredEvent = new CustomEvent('nav' + eventType, { bubbles: true, cancelable: true, detail: data });
                    return containerElement.dispatchEvent(triggeredEvent);
                }
            }

            /**
             * Get the value of the CSS custom property of the element
             * @function readCssVar
             * @param element {Node}
             * @param varName {string} - The name of the css custom property without '--'
             * @returns {string} The value of the css custom property
             */
            function readCssVar(element, varName) {
                return element.style.getPropertyValue(`--${varName}`).trim();
            }

            /**
             * Decide whether or not the 'contain' value is given to 'spatial-navigation-contain' css property of an element
             * @function isCSSSpatNavContain
             * @param element {Node}
             * @returns {boolean}
             */
            function isCSSSpatNavContain(element) {
                return readCssVar(element, 'spatial-navigation-contain') === 'contain';
            }

            /**
             * Return the value of 'spatial-navigation-action' css property of an element
             * @function getCSSSpatNavAction
             * @param element {Node} - would be the spatial navigation container
             * @returns {string} auto | focus | scroll
             */
            function getCSSSpatNavAction(element) {
                return readCssVar(element, 'spatial-navigation-action') || 'auto';
            }

            /**
             * Only move the focus with spatial navigation. Manually scrolling isn't available.
             * @function navigateChain
             * @param eventTarget {Node} - currently focused element
             * @param container {SpatialNavigationContainer} - container
             * @param parentContainer {SpatialNavigationContainer} - parent container
             * @param option - visible || all
             * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
             */
            function navigateChain(eventTarget, container, parentContainer, dir, option) {
                let currentOption = { candidates: getSpatialNavigationCandidates(container, { mode: option }), container };

                while (parentContainer) {
                    if (focusingController(eventTarget.spatialNavigationSearch(dir, currentOption), dir)) {
                        return;
                    } else {
                        if ((option === 'visible') && scrollingController(container, dir)) return;
                        else {
                            if (!createSpatNavEvents('notarget', container, eventTarget, dir)) return;

                            // find the container
                            if (container === document || container === document.documentElement) {
                                if (window.location !== window.parent.location) {
                                    // The page is in an iframe. eventTarget needs to be reset because the position of the element in the iframe
                                    eventTarget = window.frameElement;
                                    container = eventTarget.ownerDocument.documentElement;
                                }
                            } else {
                                container = parentContainer;
                            }
                            currentOption = { candidates: getSpatialNavigationCandidates(container, { mode: option }), container };
                            let nextContainer = container.getSpatialNavigationContainer();

                            if (nextContainer !== container) {
                                parentContainer = nextContainer;
                            } else {
                                parentContainer = null;
                            }
                        }
                    }
                }

                currentOption = { candidates: getSpatialNavigationCandidates(container, { mode: option }), container };

                // Behavior after 'navnotarget' - Getting out from the current spatnav container
                if ((!parentContainer && container) && focusingController(eventTarget.spatialNavigationSearch(dir, currentOption), dir)) return;

                if (!createSpatNavEvents('notarget', currentOption.container, eventTarget, dir)) return;

                if ((getCSSSpatNavAction(container) === 'auto') && (option === 'visible')) {
                    if (scrollingController(container, dir)) return;
                }
            }

            /**
             * Find search origin
             * @see {@link https://drafts.csswg.org/css-nav-1/#nav}
             * @function findSearchOrigin
             * @returns {Node} The search origin for the spatial navigation
             */
            function findSearchOrigin() {
                let searchOrigin = document.activeElement;

                if (!searchOrigin || (searchOrigin === document.body && !document.querySelector(':focus'))) {
                    // When the previous search origin lost its focus by blur: (1) disable attribute (2) visibility: hidden
                    if (savedSearchOrigin.element && (searchOrigin !== savedSearchOrigin.element)) {
                        const elementStyle = window.getComputedStyle(savedSearchOrigin.element, null);
                        const invisibleStyle = ['hidden', 'collapse'];

                        if (savedSearchOrigin.element.disabled || invisibleStyle.includes(elementStyle.getPropertyValue('visibility'))) {
                            searchOrigin = savedSearchOrigin.element;
                            return searchOrigin;
                        }
                    }
                    searchOrigin = document.documentElement;
                }
                // When the previous search origin lost its focus by blur: (1) display:none () element size turned into zero
                if (savedSearchOrigin.element &&
                    ((getBoundingClientRect(savedSearchOrigin.element).height === 0) || (getBoundingClientRect(savedSearchOrigin.element).width === 0))) {
                    searchOriginRect = savedSearchOrigin.rect;
                }

                if (!isVisibleInScroller(searchOrigin)) {
                    const scroller = getScrollContainer(searchOrigin);
                    if (scroller && ((scroller === window) || (getCSSSpatNavAction(scroller) === 'auto')))
                        return scroller;
                }
                return searchOrigin;
            }

            /**
             * Move the scroll of an element depending on the given spatial navigation directrion
             * (Assume that User Agent defined distance is '40px')
             * @see {@link https://drafts.csswg.org/css-nav-1/#directionally-scroll-an-element}
             * @function moveScroll
             * @param element {Node} - The scrollable element
             * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
             * @param offset {Number} - The explicit amount of offset for scrolling. Default value is 0.
             */
            function moveScroll(element, dir, offset = 0) {
                if (element) {
                    switch (dir) {
                        case 'left': element.scrollLeft -= (40 + offset); break;
                        case 'right': element.scrollLeft += (40 + offset); break;
                        case 'up': element.scrollTop -= (40 + offset); break;
                        case 'down': element.scrollTop += (40 + offset); break;
                    }
                }
            }

            /**
             * Decide whether an element is container or not.
             * @function isContainer
             * @param element {Node} element
             * @returns {boolean}
             */
            function isContainer(element) {
                return (!element.parentElement) ||
                    (element.nodeName === 'IFRAME') ||
                    (isScrollContainer(element)) ||
                    (isCSSSpatNavContain(element));
            }

            /**
             * Decide whether an element is delegable container or not.
             * NOTE: THIS IS NON-NORMATIVE API. 
             * @function isDelegableContainer
             * @param element {Node} element
             * @returns {boolean}
             */
            function isDelegableContainer(element) {
                return readCssVar(element, 'spatial-navigation-contain') === 'delegable';
            }

            /**
             * Decide whether an element is a scrollable container or not.
             * @see {@link https://drafts.csswg.org/css-overflow-3/#scroll-container}
             * @function isScrollContainer
             * @param element {Node}
             * @returns {boolean}
             */
            function isScrollContainer(element) {
                const elementStyle = window.getComputedStyle(element, null);
                const overflowX = elementStyle.getPropertyValue('overflow-x');
                const overflowY = elementStyle.getPropertyValue('overflow-y');

                return ((overflowX !== 'visible' && overflowX !== 'clip' && isOverflow(element, 'left')) ||
                    (overflowY !== 'visible' && overflowY !== 'clip' && isOverflow(element, 'down'))) ?
                    true : false;
            }

            /**
             * Decide whether this element is scrollable or not.
             * NOTE: If the value of 'overflow' is given to either 'visible', 'clip', or 'hidden', the element isn't scrollable.
             *       If the value is 'hidden', the element can be only programmically scrollable. (https://drafts.csswg.org/css-overflow-3/#valdef-overflow-hidden)
             * @function isScrollable
             * @param element {Node}
             * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
             * @returns {boolean}
             */
            function isScrollable(element, dir) { // element, dir
                if (element && typeof element === 'object') {
                    if (dir && typeof dir === 'string') { // parameter: dir, element
                        if (isOverflow(element, dir)) {
                            // style property
                            const elementStyle = window.getComputedStyle(element, null);
                            const overflowX = elementStyle.getPropertyValue('overflow-x');
                            const overflowY = elementStyle.getPropertyValue('overflow-y');

                            switch (dir) {
                                case 'left':
                                /* falls through */
                                case 'right':
                                    return (overflowX !== 'visible' && overflowX !== 'clip' && overflowX !== 'hidden');
                                case 'up':
                                /* falls through */
                                case 'down':
                                    return (overflowY !== 'visible' && overflowY !== 'clip' && overflowY !== 'hidden');
                            }
                        }
                        return false;
                    } else { // parameter: element
                        return (element.nodeName === 'HTML' || element.nodeName === 'BODY') ||
                            (isScrollContainer(element) && isOverflow(element));
                    }
                }
            }

            /**
             * Decide whether an element is overflow or not.
             * @function isOverflow
             * @param element {Node}
             * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
             * @returns {boolean}
             */
            function isOverflow(element, dir) {
                if (element && typeof element === 'object') {
                    if (dir && typeof dir === 'string') { // parameter: element, dir
                        switch (dir) {
                            case 'left':
                            /* falls through */
                            case 'right':
                                return (element.scrollWidth > element.clientWidth);
                            case 'up':
                            /* falls through */
                            case 'down':
                                return (element.scrollHeight > element.clientHeight);
                        }
                    } else { // parameter: element
                        return (element.scrollWidth > element.clientWidth || element.scrollHeight > element.clientHeight);
                    }
                    return false;
                }
            }

            /**
             * Decide whether the scrollbar of the browsing context reaches to the end or not.
             * @function isHTMLScrollBoundary
             * @param element {Node} - The top browsing context
             * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
             * @returns {boolean}
             */
            function isHTMLScrollBoundary(element, dir) {
                let result = false;
                switch (dir) {
                    case 'left':
                        result = element.scrollLeft === 0;
                        break;
                    case 'right':
                        result = (element.scrollWidth - element.scrollLeft - element.clientWidth) === 0;
                        break;
                    case 'up':
                        result = element.scrollTop === 0;
                        break;
                    case 'down':
                        result = (element.scrollHeight - element.scrollTop - element.clientHeight) === 0;
                        break;
                }
                return result;
            }

            /**
             * Decide whether the scrollbar of an element reaches to the end or not.
             * @function isScrollBoundary
             * @param element {Node}
             * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
             * @returns {boolean}
             */
            function isScrollBoundary(element, dir) {
                if (isScrollable(element, dir)) {
                    const winScrollY = element.scrollTop;
                    const winScrollX = element.scrollLeft;

                    const height = element.scrollHeight - element.clientHeight;
                    const width = element.scrollWidth - element.clientWidth;

                    switch (dir) {
                        case 'left': return (winScrollX === 0);
                        case 'right': return (Math.abs(winScrollX - width) <= 1);
                        case 'up': return (winScrollY === 0);
                        case 'down': return (Math.abs(winScrollY - height) <= 1);
                    }
                }
                return false;
            }

            /**
             * Decide whether an element is inside the scorller viewport or not
             *
             * @function isVisibleInScroller
             * @param element {Node}
             * @returns {boolean}
             */
            function isVisibleInScroller(element) {
                const elementRect = element.getBoundingClientRect();
                let nearestScroller = getScrollContainer(element);

                let scrollerRect = null;
                if (nearestScroller !== window) {
                    scrollerRect = getBoundingClientRect(nearestScroller);
                } else {
                    scrollerRect = new DOMRect(0, 0, window.innerWidth, window.innerHeight);
                }

                if (isInside(scrollerRect, elementRect, 'left') && isInside(scrollerRect, elementRect, 'down'))
                    return true;
                else
                    return false;
            }

            /**
             * Decide whether an element is focusable for spatial navigation.
             * 1. If element is the browsing context (document, iframe), then it's focusable,
             * 2. If the element is scrollable container (regardless of scrollable axis), then it's focusable,
             * 3. The value of tabIndex >= 0, then it's focusable,
             * 4. If the element is disabled, it isn't focusable,
             * 5. If the element is expressly inert, it isn't focusable,
             * 6. Whether the element is being rendered or not.
             *
             * @function isFocusable
             * @param element {Node}
             * @returns {boolean}
             *
             * @see {@link https://html.spec.whatwg.org/multipage/interaction.html#focusable-area}
             */
            function isFocusable(element) {
                if ((element.tabIndex < 0) || isAtagWithoutHref(element) || isActuallyDisabled(element) || isExpresslyInert(element) || !isBeingRendered(element))
                    return false;
                else if ((!element.parentElement) || (isScrollable(element) && isOverflow(element)) || (element.tabIndex >= 0))
                    return true;
            }

            /**
             * Decide whether an element is a tag without href attribute or not.
             *
             * @function isAtagWithoutHref
             * @param element {Node}
             * @returns {boolean}
             */
            function isAtagWithoutHref(element) {
                return (element.tagName === 'A' && element.getAttribute('href') === null && element.getAttribute('tabIndex') === null);
            }

            /**
             * Decide whether an element is actually disabled or not.
             *
             * @function isActuallyDisabled
             * @param element {Node}
             * @returns {boolean}
             *
             * @see {@link https://html.spec.whatwg.org/multipage/semantics-other.html#concept-element-disabled}
             */
            function isActuallyDisabled(element) {
                if (['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'OPTGROUP', 'OPTION', 'FIELDSET'].includes(element.tagName))
                    return (element.disabled);
                else
                    return false;
            }

            /**
             * Decide whether the element is expressly inert or not.
             * @see {@link https://html.spec.whatwg.org/multipage/interaction.html#expressly-inert}
             * @function isExpresslyInert
             * @param element {Node}
             * @returns {boolean}
             */
            function isExpresslyInert(element) {
                return ((element.inert) && (!element.ownerDocument.documentElement.inert));
            }

            /**
             * Decide whether the element is being rendered or not.
             * 1. If an element has the style as "visibility: hidden | collapse" or "display: none", it is not being rendered.
             * 2. If an element has the style as "opacity: 0", it is not being rendered.(that is, invisible).
             * 3. If width and height of an element are explicitly set to 0, it is not being rendered.
             * 4. If a parent element is hidden, an element itself is not being rendered.
             * (CSS visibility property and display property are inherited.)
             * @see {@link https://html.spec.whatwg.org/multipage/rendering.html#being-rendered}
             * @function isBeingRendered
             * @param element {Node}
             * @returns {boolean}
             */
            function isBeingRendered(element) {
                if (!isVisibleStyleProperty(element.parentElement))
                    return false;
                if (!isVisibleStyleProperty(element) || (element.style.opacity === '0') ||
                    (window.getComputedStyle(element).height === '0px' || window.getComputedStyle(element).width === '0px'))
                    return false;
                return true;
            }

            /**
             * Decide whether this element is partially or completely visible to user agent.
             * @function isVisible
             * @param element {Node}
             * @returns {boolean}
             */
            function isVisible(element) {
                return (!element.parentElement) || (isVisibleStyleProperty(element) && hitTest(element));
            }

            /**
             * Decide whether this element is completely visible in this viewport for the arrow direction.
             * @function isEntirelyVisible
             * @param element {Node}
             * @returns {boolean}
             */
            function isEntirelyVisible(element, container) {
                const rect = getBoundingClientRect(element);
                const containerElm = container || element.getSpatialNavigationContainer();
                const containerRect = getBoundingClientRect(containerElm);

                // FIXME: when element is bigger than container?
                const entirelyVisible = !((rect.left < containerRect.left) ||
                    (rect.right > containerRect.right) ||
                    (rect.top < containerRect.top) ||
                    (rect.bottom > containerRect.bottom));

                return entirelyVisible;
            }

            /**
             * Decide the style property of this element is specified whether it's visible or not.
             * @function isVisibleStyleProperty
             * @param element {CSSStyleDeclaration}
             * @returns {boolean}
             */
            function isVisibleStyleProperty(element) {
                const elementStyle = window.getComputedStyle(element, null);
                const thisVisibility = elementStyle.getPropertyValue('visibility');
                const thisDisplay = elementStyle.getPropertyValue('display');
                const invisibleStyle = ['hidden', 'collapse'];

                return (thisDisplay !== 'none' && !invisibleStyle.includes(thisVisibility));
            }

            /**
             * Decide whether this element is entirely or partially visible within the viewport.
             * @function hitTest
             * @param element {Node}
             * @returns {boolean}
             */
            function hitTest(element) {
                const elementRect = getBoundingClientRect(element);
                if (element.nodeName !== 'IFRAME' && (elementRect.top < 0 || elementRect.left < 0 ||
                    elementRect.top > element.ownerDocument.documentElement.clientHeight || elementRect.left > element.ownerDocument.documentElement.clientWidth))
                    return false;

                let offsetX = parseInt(element.offsetWidth) / 10;
                let offsetY = parseInt(element.offsetHeight) / 10;

                offsetX = isNaN(offsetX) ? 1 : offsetX;
                offsetY = isNaN(offsetY) ? 1 : offsetY;

                const hitTestPoint = {
                    // For performance, just using the three point(middle, leftTop, rightBottom) of the element for hit testing
                    middle: [(elementRect.left + elementRect.right) / 2, (elementRect.top + elementRect.bottom) / 2],
                    leftTop: [elementRect.left + offsetX, elementRect.top + offsetY],
                    rightBottom: [elementRect.right - offsetX, elementRect.bottom - offsetY]
                };

                for (const point in hitTestPoint) {
                    const elemFromPoint = element.ownerDocument.elementFromPoint(...hitTestPoint[point]);
                    if (element === elemFromPoint || element.contains(elemFromPoint)) {
                        return true;
                    }
                }
                return false;
            }

            /**
             * Decide whether a child element is entirely or partially Included within container visually.
             * @function isInside
             * @param containerRect {DOMRect}
             * @param childRect {DOMRect}
             * @returns {boolean}
             */
            function isInside(containerRect, childRect) {
                const rightEdgeCheck = (containerRect.left <= childRect.right && containerRect.right >= childRect.right);
                const leftEdgeCheck = (containerRect.left <= childRect.left && containerRect.right >= childRect.left);
                const topEdgeCheck = (containerRect.top <= childRect.top && containerRect.bottom >= childRect.top);
                const bottomEdgeCheck = (containerRect.top <= childRect.bottom && containerRect.bottom >= childRect.bottom);
                return (rightEdgeCheck || leftEdgeCheck) && (topEdgeCheck || bottomEdgeCheck);
            }

            /**
             * Decide whether this element is entirely or partially visible within the viewport.
             * Note: rect1 is outside of rect2 for the dir
             * @function isOutside
             * @param rect1 {DOMRect}
             * @param rect2 {DOMRect}
             * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
             * @returns {boolean}
             */
            function isOutside(rect1, rect2, dir) {
                switch (dir) {
                    case 'left':
                        return isRightSide(rect2, rect1);
                    case 'right':
                        return isRightSide(rect1, rect2);
                    case 'up':
                        return isBelow(rect2, rect1);
                    case 'down':
                        return isBelow(rect1, rect2);
                    default:
                        return false;
                }
            }

            /* rect1 is right of rect2 */
            function isRightSide(rect1, rect2) {
                return rect1.left >= rect2.right || (rect1.left >= rect2.left && rect1.right > rect2.right && rect1.bottom > rect2.top && rect1.top < rect2.bottom);
            }

            /* rect1 is below of rect2 */
            function isBelow(rect1, rect2) {
                return rect1.top >= rect2.bottom || (rect1.top >= rect2.top && rect1.bottom > rect2.bottom && rect1.left < rect2.right && rect1.right > rect2.left);
            }

            /* rect1 is completely aligned or partially aligned for the direction */
            function isAligned(rect1, rect2, dir) {
                switch (dir) {
                    case 'left':
                    /* falls through */
                    case 'right':
                        return rect1.bottom > rect2.top && rect1.top < rect2.bottom;
                    case 'up':
                    /* falls through */
                    case 'down':
                        return rect1.right > rect2.left && rect1.left < rect2.right;
                    default:
                        return false;
                }
            }

            /**
             * Get distance between the search origin and a candidate element along the direction when candidate element is inside the search origin.
             * @see {@link https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance}
             * @function getDistanceFromPoint
             * @param point {Point} - The search origin
             * @param element {DOMRect} - A candidate element
             * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
             * @returns {Number} The euclidian distance between the spatial navigation container and an element inside it
             */
            function getDistanceFromPoint(point, element, dir) {
                point = startingPoint;
                // Get exit point, entry point -> {x: '', y: ''};
                const points = getEntryAndExitPoints(dir, point, element);

                // Find the points P1 inside the border box of starting point and P2 inside the border box of candidate
                // that minimize the distance between these two points
                const P1 = Math.abs(points.entryPoint.x - points.exitPoint.x);
                const P2 = Math.abs(points.entryPoint.y - points.exitPoint.y);

                // The result is euclidian distance between P1 and P2.
                return Math.sqrt(Math.pow(P1, 2) + Math.pow(P2, 2));
            }

            /**
             * Get distance between the search origin and a candidate element along the direction when candidate element is inside the search origin.
             * @see {@link https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance}
             * @function getInnerDistance
             * @param rect1 {DOMRect} - The search origin
             * @param rect2 {DOMRect} - A candidate element
             * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
             * @returns {Number} The euclidean distance between the spatial navigation container and an element inside it
             */
            function getInnerDistance(rect1, rect2, dir) {
                const baseEdgeForEachDirection = { left: 'right', right: 'left', up: 'bottom', down: 'top' };
                const baseEdge = baseEdgeForEachDirection[dir];

                return Math.abs(rect1[baseEdge] - rect2[baseEdge]);
            }

            /**
             * Get the distance between the search origin and a candidate element considering the direction.
             * @see {@link https://drafts.csswg.org/css-nav-1/#calculating-the-distance}
             * @function getDistance
             * @param searchOrigin {DOMRect | Point} - The search origin
             * @param candidateRect {DOMRect} - A candidate element
             * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
             * @returns {Number} The distance scoring between two elements
             */
            function getDistance(searchOrigin, candidateRect, dir) {
                const kOrthogonalWeightForLeftRight = 30;
                const kOrthogonalWeightForUpDown = 2;

                let orthogonalBias = 0;
                let alignBias = 0;
                const alignWeight = 5.0;

                // Get exit point, entry point -> {x: '', y: ''};
                const points = getEntryAndExitPoints(dir, searchOrigin, candidateRect);

                // Find the points P1 inside the border box of starting point and P2 inside the border box of candidate
                // that minimize the distance between these two points
                const P1 = Math.abs(points.entryPoint.x - points.exitPoint.x);
                const P2 = Math.abs(points.entryPoint.y - points.exitPoint.y);

                // A: The euclidean distance between P1 and P2.
                const A = Math.sqrt(Math.pow(P1, 2) + Math.pow(P2, 2));
                let B, C;

                // B: The absolute distance in the direction which is orthogonal to dir between P1 and P2, or 0 if dir is null.
                // C: The intersection edges between a candidate and the starting point.

                // D: The square root of the area of intersection between the border boxes of candidate and starting point
                const intersectionRect = getIntersectionRect(searchOrigin, candidateRect);
                const D = intersectionRect.area;

                switch (dir) {
                    case 'left':
                    /* falls through */
                    case 'right':
                        // If two elements are aligned, add align bias
                        // else, add orthogonal bias
                        if (isAligned(searchOrigin, candidateRect, dir))
                            alignBias = Math.min(intersectionRect.height / searchOrigin.height, 1);
                        else
                            orthogonalBias = (searchOrigin.height / 2);

                        B = (P2 + orthogonalBias) * kOrthogonalWeightForLeftRight;
                        C = alignWeight * alignBias;
                        break;

                    case 'up':
                    /* falls through */
                    case 'down':
                        // If two elements are aligned, add align bias
                        // else, add orthogonal bias
                        if (isAligned(searchOrigin, candidateRect, dir))
                            alignBias = Math.min(intersectionRect.width / searchOrigin.width, 1);
                        else
                            orthogonalBias = (searchOrigin.width / 2);

                        B = (P1 + orthogonalBias) * kOrthogonalWeightForUpDown;
                        C = alignWeight * alignBias;
                        break;

                    default:
                        B = 0;
                        C = 0;
                        break;
                }

                return (A + B - C - D);
            }

            /**
             * Get the euclidean distance between the search origin and a candidate element considering the direction.
             * @function getEuclideanDistance
             * @param rect1 {DOMRect} - The search origin
             * @param rect2 {DOMRect} - A candidate element
             * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
             * @returns {Number} The distance scoring between two elements
             */
            function getEuclideanDistance(rect1, rect2, dir) {
                // Get exit point, entry point
                const points = getEntryAndExitPoints(dir, rect1, rect2);

                // Find the points P1 inside the border box of starting point and P2 inside the border box of candidate
                // that minimize the distance between these two points
                const P1 = Math.abs(points.entryPoint.x - points.exitPoint.x);
                const P2 = Math.abs(points.entryPoint.y - points.exitPoint.y);

                // Return the euclidean distance between P1 and P2.
                return Math.sqrt(Math.pow(P1, 2) + Math.pow(P2, 2));
            }

            /**
             * Get the absolute distance between the search origin and a candidate element considering the direction.
             * @function getAbsoluteDistance
             * @param rect1 {DOMRect} - The search origin
             * @param rect2 {DOMRect} - A candidate element
             * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
             * @returns {Number} The distance scoring between two elements
             */
            function getAbsoluteDistance(rect1, rect2, dir) {
                // Get exit point, entry point
                const points = getEntryAndExitPoints(dir, rect1, rect2);

                // Return the absolute distance in the dir direction between P1 and P.
                return ((dir === 'left') || (dir === 'right')) ?
                    Math.abs(points.entryPoint.x - points.exitPoint.x) : Math.abs(points.entryPoint.y - points.exitPoint.y);
            }

            /**
             * Get entry point and exit point of two elements considering the direction.
             * @function getEntryAndExitPoints
             * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD). Default value for dir is 'down'.
             * @param searchOrigin {DOMRect | Point} - The search origin which contains the exit point
             * @param candidateRect {DOMRect} - One of candidates which contains the entry point
             * @returns {Points} The exit point from the search origin and the entry point from a candidate
             */
            function getEntryAndExitPoints(dir = 'down', searchOrigin, candidateRect) {
                /**
                 * User type definition for Point
                 * @typeof {Object} Points
                 * @property {Point} Points.entryPoint
                 * @property {Point} Points.exitPoint
                 */
                const points = { entryPoint: { x: 0, y: 0 }, exitPoint: { x: 0, y: 0 } };

                if (startingPoint) {
                    points.exitPoint = searchOrigin;

                    switch (dir) {
                        case 'left':
                            points.entryPoint.x = candidateRect.right;
                            break;
                        case 'up':
                            points.entryPoint.y = candidateRect.bottom;
                            break;
                        case 'right':
                            points.entryPoint.x = candidateRect.left;
                            break;
                        case 'down':
                            points.entryPoint.y = candidateRect.top;
                            break;
                    }

                    // Set orthogonal direction
                    switch (dir) {
                        case 'left':
                        case 'right':
                            if (startingPoint.y <= candidateRect.top) {
                                points.entryPoint.y = candidateRect.top;
                            } else if (startingPoint.y < candidateRect.bottom) {
                                points.entryPoint.y = startingPoint.y;
                            } else {
                                points.entryPoint.y = candidateRect.bottom;
                            }
                            break;

                        case 'up':
                        case 'down':
                            if (startingPoint.x <= candidateRect.left) {
                                points.entryPoint.x = candidateRect.left;
                            } else if (startingPoint.x < candidateRect.right) {
                                points.entryPoint.x = startingPoint.x;
                            } else {
                                points.entryPoint.x = candidateRect.right;
                            }
                            break;
                    }
                }
                else {
                    // Set direction
                    switch (dir) {
                        case 'left':
                            points.exitPoint.x = searchOrigin.left;
                            points.entryPoint.x = (candidateRect.right < searchOrigin.left) ? candidateRect.right : searchOrigin.left;
                            break;
                        case 'up':
                            points.exitPoint.y = searchOrigin.top;
                            points.entryPoint.y = (candidateRect.bottom < searchOrigin.top) ? candidateRect.bottom : searchOrigin.top;
                            break;
                        case 'right':
                            points.exitPoint.x = searchOrigin.right;
                            points.entryPoint.x = (candidateRect.left > searchOrigin.right) ? candidateRect.left : searchOrigin.right;
                            break;
                        case 'down':
                            points.exitPoint.y = searchOrigin.bottom;
                            points.entryPoint.y = (candidateRect.top > searchOrigin.bottom) ? candidateRect.top : searchOrigin.bottom;
                            break;
                    }

                    // Set orthogonal direction
                    switch (dir) {
                        case 'left':
                        case 'right':
                            if (isBelow(searchOrigin, candidateRect)) {
                                points.exitPoint.y = searchOrigin.top;
                                points.entryPoint.y = (candidateRect.bottom < searchOrigin.top) ? candidateRect.bottom : searchOrigin.top;
                            } else if (isBelow(candidateRect, searchOrigin)) {
                                points.exitPoint.y = searchOrigin.bottom;
                                points.entryPoint.y = (candidateRect.top > searchOrigin.bottom) ? candidateRect.top : searchOrigin.bottom;
                            } else {
                                points.exitPoint.y = Math.max(searchOrigin.top, candidateRect.top);
                                points.entryPoint.y = points.exitPoint.y;
                            }
                            break;

                        case 'up':
                        case 'down':
                            if (isRightSide(searchOrigin, candidateRect)) {
                                points.exitPoint.x = searchOrigin.left;
                                points.entryPoint.x = (candidateRect.right < searchOrigin.left) ? candidateRect.right : searchOrigin.left;
                            } else if (isRightSide(candidateRect, searchOrigin)) {
                                points.exitPoint.x = searchOrigin.right;
                                points.entryPoint.x = (candidateRect.left > searchOrigin.right) ? candidateRect.left : searchOrigin.right;
                            } else {
                                points.exitPoint.x = Math.max(searchOrigin.left, candidateRect.left);
                                points.entryPoint.x = points.exitPoint.x;
                            }
                            break;
                    }
                }

                return points;
            }

            /**
             * Find focusable elements within the container
             * @see {@link https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance}
             * @function getIntersectionRect
             * @param rect1 {DOMRect} - The search origin which contains the exit point
             * @param rect2 {DOMRect} - One of candidates which contains the entry point
             * @returns {IntersectionArea} The intersection area between two elements.
             *
             * @typeof {Object} IntersectionArea
             * @property {Number} IntersectionArea.width
             * @property {Number} IntersectionArea.height
             */
            function getIntersectionRect(rect1, rect2) {
                const intersection_rect = { width: 0, height: 0, area: 0 };

                const new_location = [Math.max(rect1.left, rect2.left), Math.max(rect1.top, rect2.top)];
                const new_max_point = [Math.min(rect1.right, rect2.right), Math.min(rect1.bottom, rect2.bottom)];

                intersection_rect.width = Math.abs(new_location[0] - new_max_point[0]);
                intersection_rect.height = Math.abs(new_location[1] - new_max_point[1]);

                if (!(new_location[0] >= new_max_point[0] || new_location[1] >= new_max_point[1])) {
                    // intersecting-cases
                    intersection_rect.area = Math.sqrt(intersection_rect.width * intersection_rect.height);
                }

                return intersection_rect;
            }

            /**
             * Handle the spatial navigation behavior for HTMLInputElement, HTMLTextAreaElement
             * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input|HTMLInputElement (MDN)}
             * @function handlingEditableElement
             * @param e {Event} - keydownEvent
             * @returns {boolean}
             */
            function handlingEditableElement(e) {
                const SPINNABLE_INPUT_TYPES = ['email', 'date', 'month', 'number', 'time', 'week'],
                    TEXT_INPUT_TYPES = ['password', 'text', 'search', 'tel', 'url', null];
                const eventTarget = document.activeElement;
                const startPosition = eventTarget.selectionStart;
                const endPosition = eventTarget.selectionEnd;
                const focusNavigableArrowKey = { left: false, up: false, right: false, down: false };

                const dir = ARROW_KEY_CODE[e.keyCode];
                if (dir === undefined) {
                    return focusNavigableArrowKey;
                }

                if (SPINNABLE_INPUT_TYPES.includes(eventTarget.getAttribute('type')) &&
                    (dir === 'up' || dir === 'down')) {
                    focusNavigableArrowKey[dir] = true;
                } else if (TEXT_INPUT_TYPES.includes(eventTarget.getAttribute('type')) || eventTarget.nodeName === 'TEXTAREA') {
                    if (startPosition === endPosition) { // if there isn't any selected text
                        if (startPosition === 0) {
                            focusNavigableArrowKey.left = true;
                            focusNavigableArrowKey.up = true;
                        }
                        if (endPosition === eventTarget.value.length) {
                            focusNavigableArrowKey.right = true;
                            focusNavigableArrowKey.down = true;
                        }
                    }
                } else { // HTMLDataListElement, HTMLSelectElement, HTMLOptGroup
                    focusNavigableArrowKey[dir] = true;
                }

                return focusNavigableArrowKey;
            }

            /**
             * Get the DOMRect of an element
             * @function getBoundingClientRect
             * @param {Node} element 
             * @returns {DOMRect}
             */
            function getBoundingClientRect(element) {
                // memoization
                let rect = mapOfBoundRect && mapOfBoundRect.get(element);
                if (!rect) {
                    const boundingClientRect = element.getBoundingClientRect();
                    rect = {
                        top: Number(boundingClientRect.top.toFixed(2)),
                        right: Number(boundingClientRect.right.toFixed(2)),
                        bottom: Number(boundingClientRect.bottom.toFixed(2)),
                        left: Number(boundingClientRect.left.toFixed(2)),
                        width: Number(boundingClientRect.width.toFixed(2)),
                        height: Number(boundingClientRect.height.toFixed(2))
                    };
                    mapOfBoundRect && mapOfBoundRect.set(element, rect);
                }
                return rect;
            }

            /**
             * Get the candidates which is fully inside the target element in visual
             * @param {Node} targetElement
             * @returns {sequence<Node>}  overlappedCandidates
             */
            function getOverlappedCandidates(targetElement) {
                const container = targetElement.getSpatialNavigationContainer();
                const candidates = container.focusableAreas();
                const overlappedCandidates = [];

                candidates.forEach(element => {
                    if ((targetElement !== element) && isEntirelyVisible(element, targetElement)) {
                        overlappedCandidates.push(element);
                    }
                });

                return overlappedCandidates;
            }

            /**
             * Get the list of the experimental APIs
             * @function getExperimentalAPI
             */
            function getExperimentalAPI() {
                function canScroll(container, dir) {
                    return (isScrollable(container, dir) && !isScrollBoundary(container, dir)) ||
                        (!container.parentElement && !isHTMLScrollBoundary(container, dir));
                }

                function findTarget(findCandidate, element, dir, option) {
                    let eventTarget = element;
                    let bestNextTarget = null;

                    // 4
                    if (eventTarget === document || eventTarget === document.documentElement) {
                        eventTarget = document.body || document.documentElement;
                    }

                    // 5
                    // At this point, spatialNavigationSearch can be applied.
                    // If startingPoint is either a scroll container or the document,
                    // find the best candidate within startingPoint
                    if ((isContainer(eventTarget) || eventTarget.nodeName === 'BODY') && !(eventTarget.nodeName === 'INPUT')) {
                        if (eventTarget.nodeName === 'IFRAME')
                            eventTarget = eventTarget.contentDocument.body;

                        const candidates = getSpatialNavigationCandidates(eventTarget, option);

                        // 5-2
                        if (Array.isArray(candidates) && candidates.length > 0) {
                            return findCandidate ? getFilteredSpatialNavigationCandidates(eventTarget, dir, candidates) : eventTarget.spatialNavigationSearch(dir, { candidates });
                        }
                        if (canScroll(eventTarget, dir)) {
                            return findCandidate ? [] : eventTarget;
                        }
                    }

                    // 6
                    // Let container be the nearest ancestor of eventTarget
                    let container = eventTarget.getSpatialNavigationContainer();
                    let parentContainer = (container.parentElement) ? container.getSpatialNavigationContainer() : null;

                    // When the container is the viewport of a browsing context
                    if (!parentContainer && (window.location !== window.parent.location)) {
                        parentContainer = window.parent.document.documentElement;
                    }

                    // 7
                    while (parentContainer) {
                        const candidates = filteredCandidates(eventTarget, getSpatialNavigationCandidates(container, option), dir, container);

                        if (Array.isArray(candidates) && candidates.length > 0) {
                            bestNextTarget = eventTarget.spatialNavigationSearch(dir, { candidates, container });
                            if (bestNextTarget) {
                                return findCandidate ? candidates : bestNextTarget;
                            }
                        }

                        // If there isn't any candidate and the best candidate among candidate:
                        // 1) Scroll or 2) Find candidates of the ancestor container
                        // 8 - if
                        else if (canScroll(container, dir)) {
                            return findCandidate ? [] : eventTarget;
                        } else if (container === document || container === document.documentElement) {
                            container = window.document.documentElement;

                            // The page is in an iframe
                            if (window.location !== window.parent.location) {
                                // eventTarget needs to be reset because the position of the element in the IFRAME
                                // is unuseful when the focus moves out of the iframe
                                eventTarget = window.frameElement;
                                container = window.parent.document.documentElement;
                                if (container.parentElement)
                                    parentContainer = container.getSpatialNavigationContainer();
                                else {
                                    parentContainer = null;
                                    break;
                                }
                            }
                        } else {
                            // avoiding when spatnav container with tabindex=-1
                            if (isFocusable(container)) {
                                eventTarget = container;
                            }

                            container = parentContainer;
                            if (container.parentElement)
                                parentContainer = container.getSpatialNavigationContainer();
                            else {
                                parentContainer = null;
                                break;
                            }
                        }
                    }

                    if (!parentContainer && container) {
                        // Getting out from the current spatnav container
                        const candidates = filteredCandidates(eventTarget, getSpatialNavigationCandidates(container, option), dir, container);

                        // 9
                        if (Array.isArray(candidates) && candidates.length > 0) {
                            bestNextTarget = eventTarget.spatialNavigationSearch(dir, { candidates, container });
                            if (bestNextTarget) {
                                return findCandidate ? candidates : bestNextTarget;
                            }
                        }
                    }

                    if (canScroll(container, dir)) {
                        bestNextTarget = eventTarget;
                        return bestNextTarget;
                    }
                }

                return {
                    isContainer,
                    isScrollContainer,
                    isVisibleInScroller,
                    findCandidates: findTarget.bind(null, true),
                    findNextTarget: findTarget.bind(null, false),
                    getDistanceFromTarget: (element, candidateElement, dir) => {
                        if ((isContainer(element) || element.nodeName === 'BODY') && !(element.nodeName === 'INPUT')) {
                            if (getSpatialNavigationCandidates(element).includes(candidateElement)) {
                                return getInnerDistance(getBoundingClientRect(element), getBoundingClientRect(candidateElement), dir);
                            }
                        }
                        return getDistance(getBoundingClientRect(element), getBoundingClientRect(candidateElement), dir);
                    }
                };
            }

            /**
             * Makes to use the experimental APIs.
             * @function enableExperimentalAPIs
             * @param option {boolean} - If it is true, the experimental APIs can be used or it cannot.
             */
            function enableExperimentalAPIs(option) {
                const currentKeyMode = window.__spatialNavigation__ && window.__spatialNavigation__.keyMode;
                window.__spatialNavigation__ = (option === false) ? getInitialAPIs() : Object.assign(getInitialAPIs(), getExperimentalAPI());
                window.__spatialNavigation__.keyMode = currentKeyMode;
                Object.seal(window.__spatialNavigation__);
            }

            /**
             * Set the environment for using the spatial navigation polyfill.
             * @function getInitialAPIs
             */
            function getInitialAPIs() {
                return {
                    enableExperimentalAPIs,
                    get keyMode() { return this._keymode ? this._keymode : 'ARROW'; },
                    set keyMode(mode) { this._keymode = (['SHIFTARROW', 'ARROW', 'NONE'].includes(mode)) ? mode : 'ARROW'; },
                    setStartingPoint: function (x, y) { startingPoint = (x && y) ? { x, y } : null; }
                };
            }

            initiateSpatialNavigation();
            enableExperimentalAPIs(false);

            window.addEventListener('load', () => {
                spatialNavigationHandler();
            });
        })();
    </script>
    <script type="text/javascript">
        (function () {
            window.__onBackgroundChange = function () { };
            function setBackground(newBackground) {
                window.__background = newBackground;
                preferredBackground = newBackground;
                document.body.className = newBackground;
                window.__onBackgroundChange(newBackground);
            }
            var preferredBackground;
            try {
                preferredBackground = localStorage.getItem("background");
            } catch (err) { }
            window.__setPreferredBackground = function (newBackground) {
                setBackground(newBackground);
                try {
                    localStorage.setItem("background", newBackground);
                } catch (err) { }
            }
            var darkQuery = window.matchMedia("(prefers-color-scheme: dark)");
            darkQuery.addListener(function (event) {
                window.__setPreferredBackground(e.matches ? "dark" : "light")
            });
            setBackground(preferredBackground || (darkQuery.matches ? "dark" : "light"));
        })();</script>
    <div id="___gatsby">
        <div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper">
            <header class="header"><a class="home-link" data-focusable="true" href="/"><svg class="home-link__logo"
                        xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 423 374">
                        <g fill="#fff" stroke="#333" stroke-width="9.42">
                            <path d="M413.245 92.707 212.062 366.054 10.879 92.707h402.366Z"></path>
                            <path d="M413.245 48.414 212.062 321.762 10.879 48.414h402.366Z"></path>
                            <path d="M413.245 3.044 212.062 276.391 10.879 3.044h402.366Z"></path>
                        </g>
                    </svg>
                    <h2 class="home-link__title"><span>vim</span><span>colorschemes</span></h2>
                </a><label class="background-switch" data-testid="background-switch"><input type="checkbox"
                        class="background-switch__input" aria-label="Switch between light and dark background"
                        data-focusable="true" /></label></header>
            <main class="main repository">
                <section class="repository__content">
                    <nav class="repository__nav"><a class="repository__link" data-focusable="true" href="/"><svg
                                xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" class="icon-arrow repository__link-icon icon-arrow--left">
                                <line x1="5" y1="12" x2="19" y2="12"></line>
                                <polyline points="12 5 19 12 12 19"></polyline>
                            </svg><span>Back</span></a><a href="https://github.com/doki-theme/doki-theme-vim"
                            rel="noopener" target="_blank" class="external-link repository__link"
                            data-focusable="true"><span><span class="repository__link-extension">View
                                    <b>doki-theme-vim</b> on</span> Github</span><svg xmlns="http://www.w3.org/2000/svg"
                                width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                                class="repository__link-icon">
                                <path
                                    d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22">
                                </path>
                            </svg></a></nav>
                    <header class="meta-header repository__meta">
                        <div class="meta-header__row">
                            <div class="subtitle">doki-theme</div>
                            <div class="meta-header__statistic"><svg class="meta-header__icon"
                                    xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <polygon
                                        points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2">
                                    </polygon>
                                </svg><b>62</b></div>
                        </div>
                        <div class="meta-header__row">
                            <h1 aria-label="doki-theme-vim, by doki-theme" class="title">doki-theme-vim</h1>
                        </div>
                    </header>
                    <div class="repository__previews">
                        <h3 class="repository__previews-title subtitle"><b>More from <!-- -->doki-theme-vim</b></h3>
                        <div class="preview repository__preview preview--dark" style="--vim-StatusLineFg: #f8f8f2; --vim-vimOperParen: #f8f8f2; --vim-CursorBg: #fee3cf; --vim-vimLineComment: #6c7ea5; --vim-vimIsCommand: #61dba0; --vim-vimString: #efa554; --vim-vimNotFunc: #50cefb; --vim-vimVar: #f8f8f2; --vim-vimParenSep: #f8f8f2; --vim-vimLet: #50cefb; --vim-CursorLineNrBg: #000000; --vim-CursorLineBg: #2d2d52; --vim-CursorFg: #000000; --vim-vimFunction: #f8f8f2; --vim-vimOper: #afc8f5; --vim-vimNumber: #ffeea6; --vim-LineNrFg: #61647b; --vim-vimFuncName: #b772de; --vim-vimFuncBody: #f8f8f2; --vim-LineNrBg: #000000; --vim-vimFuncKey: #50cefb; --vim-vimSubst: #50cefb; --vim-CursorLineNrFg: #ffff00; --vim-StatusLineBg: #29294e; --vim-NormalBg: #000000; --vim-vimCommand: #50cefb; --vim-NormalFg: #f8f8f2; --vim-CursorLineFg: #000000; --vim-vimFuncVar: #f8f8f2;">
                            <header class="preview__header">
                                <div></div>
                                <div></div>
                                <div></div><code data-ignore-a11y="true"
                                    class="preview__header-file-name">mai_dark (dark)</code><code
                                    data-ignore-a11y="true" class="preview__header-type">vim</code>
                            </header>
                            <pre
                                class="code vimrc"><span class="buffer"><code class="gutter LineNrFg LineNrBg"><span class="gutter__number LineNrBg" data-ignore-a11y="true">1</span><span class="gutter__number LineNrBg" data-ignore-a11y="true">2</span></code><code class="buffer__code" aria-label="Code sample in vimscript language" tabindex="-1" data-ignore-a11y="true"><div class="vimrc__content"><span><span class="vimCommand">set</span> background<span class="vimOper">=</span><span>dark</span></span><span><span class="vimCommand">colorscheme </span><span>mai_dark</span></span></div></code></span><span class="status-line StatusLineFg StatusLineBg"><span class="status-line__content"><span class="status-line__mode StatusLineFg--inverted StatusLineBg--inverted" data-ignore-a11y="true">NORMAL</span><span data-ignore-a11y="true">.vimrc</span></span><span class="status-line__content"><span class="status-line__extension" data-ignore-a11y="true">unix</span><span class="status-line__extension" data-ignore-a11y="true">utf-8</span><span data-ignore-a11y="true">☰</span><span data-ignore-a11y="true"> 0<!-- -->%</span><span data-ignore-a11y="true"> 0:2</span></span></span></pre>
                            <pre
                                class="code preview__code"><span class="buffer"><code class="gutter LineNrFg LineNrBg"><span class="gutter__number LineNrBg" data-ignore-a11y="true">1</span><span class="gutter__number LineNrBg" data-ignore-a11y="true">2</span><span class="gutter__number LineNrBg" data-ignore-a11y="true">3</span><span class="gutter__number LineNrBg" data-ignore-a11y="true">4</span><span class="gutter__number LineNrBg" data-ignore-a11y="true">5</span><span class="gutter__number LineNrBg CursorLineNrFg CursorLineNrBg" data-ignore-a11y="true">6</span><span class="gutter__number LineNrBg" data-ignore-a11y="true">7</span><span class="gutter__number LineNrBg" data-ignore-a11y="true">8</span><span class="gutter__number LineNrBg" data-ignore-a11y="true">9</span><span class="gutter__number LineNrBg" data-ignore-a11y="true">10</span><span class="gutter__number LineNrBg" data-ignore-a11y="true">11</span><span class="gutter__number LineNrBg" data-ignore-a11y="true">12</span></code><code class="buffer__code" aria-label="Code sample in vimscript language" tabindex="-1" data-ignore-a11y="true"><span><div><span class="vimLineComment">&quot; Returns true if the color hex value is light</span></div><div><span class="vimCommand">function</span><span class="vimFunction">! IsHexColorLight</span><span class="vimParenSep">(</span><span class="vimOperParen">color</span><span class="vimParenSep">)</span><span class="vimFuncBody"> </span><span class="vimIsCommand">abort</span></div><div><span class="vimFuncBody">  </span><span class="vimLet">let</span><span class="vimFuncBody"> </span><span class="vimVar">l:raw_color</span><span class="vimFuncBody"> </span><span class="vimOper">=</span><span class="vimFuncBody"> </span><span class="vimFuncName">trim</span><span class="vimParenSep">(</span><span class="vimFuncVar">a:color</span><span class="vimOperParen">, </span><span class="vimString">'#'</span><span class="vimParenSep">)</span></div><div></div><div><span class="vimFuncBody"><br />  </span><span class="vimLet">let</span><span class="vimFuncBody"> </span><span class="vimVar">l:red</span><span class="vimFuncBody"> </span><span class="vimOper">=</span><span class="vimFuncBody"> </span><span class="vimFuncName">str2nr</span><span class="vimParenSep">(</span><span class="vimSubst">substitute</span><span class="vimParenSep">(</span><span class="vimOperParen">l:raw_color, </span><span class="vimString">'(.{2}).{4}'</span><span class="vimOperParen">, </span><span class="vimString">'1'</span><span class="vimOperParen">, </span><span class="vimString">'g'</span><span class="vimParenSep">)</span><span class="vimFuncBody">, </span><span class="vimNumber">16</span><span class="vimParenSep">)</span></div><div><span class="vimFuncBody">  </span><span class="vimLet">let</span><span class="vimFuncBody"> </span><span class="vimVar">l:green</span><span class="vimFuncBody"> </span><span class="vimOper">=</span><span class="vimFuncBody"> </span><span class="vimFuncName">str2nr</span><span class="vimParenSep">(</span><span class="vimSubst">substitute</span><span class="vimParenSep">(</span><span class="vimOperParen">l:raw_color, </span><span class="vimString">'.{2}(.{2}).{2}'</span><span class="vimOperParen">, </span><span class="vimString">'1'</span><span class="vimOperParen">, </span><span class="vimString">'g'</span><span class="vimParenSep">)</span><span class="vimFuncBody">, </span><span class="vimNumber">16</span><span class="vimParenSep">)</span></div><div><span class="vimFuncBody">  </span><span class="vimLet">let</span><span class="vimFuncBody"> </span><span class="vimVar">l:blue</span><span class="vimFuncBody"> </span><span class="vimOper">=</span><span class="vimFuncBody"> </span><span class="vimFuncName">str2nr</span><span class="vimParenSep">(</span><span class="vimSubst">substitute</span><span class="vimParenSep">(</span><span class="vimOperParen">l:raw_color, </span><span class="vimString">'.{4}(.{2})'</span><span class="vimOperParen">, </span><span class="vimString">'1'</span><span class="vimOperParen">, </span><span class="vimString">'g'</span><span class="vimParenSep">)</span><span class="vimFuncBody">, </span><span class="vimNumber">16</span><span class="vimParenSep">)</span></div><div></div><div><span class="vimFuncBody"><br />  </span><span class="vimLet">let</span><span class="vimFuncBody"> </span><span class="vimVar">l:brightness</span><span class="vimFuncBody"> </span><span class="vimOper">=</span><span class="vimFuncBody"> </span><span class="vimParenSep">((</span><span class="vimOperParen">l:red * </span><span class="vimNumber">299</span><span class="vimParenSep">)</span><span class="vimOperParen"> </span><span class="vimOper">+</span><span class="vimOperParen"> </span><span class="vimParenSep">(</span><span class="vimOperParen">l:green * </span><span class="vimNumber">587</span><span class="vimParenSep">)</span><span class="vimOperParen"> </span><span class="vimOper">+</span><span class="vimOperParen"> </span><span class="vimParenSep">(</span><span class="vimOperParen">l:blue * </span><span class="vimNumber">114</span><span class="vimParenSep">))</span><span class="vimFuncBody"> / </span><span class="vimNumber">1000</span></div><div></div><div><span class="vimFuncBody"><br />  </span><span class="vimNotFunc">return</span><span class="vimFuncBody"> </span><span class="vimVar">l:brightness</span><span class="vimFuncBody"> </span><span class="vimOper">&gt;</span><span class="vimFuncBody"> </span><span class="vimNumber">155</span></div><div><span class="vimCommand">endfunction</span></div></span></code></span><span class="status-line StatusLineFg StatusLineBg"><span class="status-line__content"><span class="status-line__mode StatusLineFg--inverted StatusLineBg--inverted" data-ignore-a11y="true">NORMAL</span><span data-ignore-a11y="true">code.vim</span></span><span class="status-line__content"><span class="status-line__extension" data-ignore-a11y="true">unix</span><span class="status-line__extension" data-ignore-a11y="true">utf-8</span><span data-ignore-a11y="true">☰</span><span data-ignore-a11y="true">50<!-- -->%</span><span data-ignore-a11y="true">6:12</span></span></span></pre>
                        </div>
                    </div>
                </section>
            </main>
            <footer class="footer">
                <nav class="footer__content" arial-label="footer navigation links">
                    <div class="footer__links"><a class="home-link" data-focusable="true" href="/"><svg
                                class="home-link__logo" xmlns="http://www.w3.org/2000/svg" fill="none"
                                viewBox="0 0 423 374">
                                <g fill="#fff" stroke="#333" stroke-width="9.42">
                                    <path d="M413.245 92.707 212.062 366.054 10.879 92.707h402.366Z"></path>
                                    <path d="M413.245 48.414 212.062 321.762 10.879 48.414h402.366Z"></path>
                                    <path d="M413.245 3.044 212.062 276.391 10.879 3.044h402.366Z"></path>
                                </g>
                            </svg><span class="home-link__title"><span>vim</span><span>colorschemes</span></span></a>
                    </div>
                    <div aria-label="footer links" class="footer__links"><a data-focusable="true"
                            data-testid="footer__about" class="footer__link" href="/about/">About</a><a
                            href="https://github.com/vimcolorschemes/vimcolorschemes" rel="noopener" target="_blank"
                            class="external-link footer__link footer__link--accent"
                            data-focusable="true"><span>Follow<!-- --> <span
                                    class="footer__link-extension">vimcolorshemes</span> on Github</span><svg
                                xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round">
                                <path
                                    d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22">
                                </path>
                            </svg></a><a href="https://github.com/reobin" rel="noopener" target="_blank"
                            class="external-link footer__link" data-focusable="true">Contact</a></div>
                </nav>
            </footer>
        </div>
        <div id="gatsby-announcer"
            style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0"
            aria-live="assertive" aria-atomic="true"></div>
    </div>
    <script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath = "/doki-theme/doki-theme-vim/";/*]]>*/</script>
    <!-- slice-start id="_gatsby-scripts-1" -->
    <script id="gatsby-chunk-mapping">
        window.___chunkMapping = "{\"app\":[\"/app-45661f52f5c5ce08fee6.js\"],\"component---src-pages-404-tsx\":[\"/component---src-pages-404-tsx-44b9dc6f5cb259dcb4c8.js\"],\"component---src-pages-about-index-tsx\":[\"/component---src-pages-about-index-tsx-5770e5a8e7ce911ff00d.js\"],\"component---src-templates-preview-index-tsx\":[\"/component---src-templates-preview-index-tsx-fb49456a7881f8db52d1.js\"],\"component---src-templates-repositories-index-tsx\":[\"/component---src-templates-repositories-index-tsx-08b27b40d3dd431be77e.js\"],\"component---src-templates-repository-index-tsx\":[\"/component---src-templates-repository-index-tsx-69849a35632d8fe802e8.js\"]}";
    </script>
    <script>window.___webpackCompilationHash = "d0fd022db9526ee6759b";</script>
    <script src="/webpack-runtime-14602578bb9af9c2ec83.js" async></script>
    <script src="/framework-46ce8dcb4cdadfd1571c.js" async></script>
    <script src="/app-45661f52f5c5ce08fee6.js" async></script><!-- slice-end id="_gatsby-scripts-1" -->
    <script defer="" src="https://static.cloudflareinsights.com/beacon.min.js"
        data-cf-beacon="{&quot;token&quot;: &quot;d8e627df3f1641dd86eabfc338de4ee4&quot;}"></script>
</body>

</html>